{"controls":[{"id":"SV-81847","code":"control 'SV-81847' do\n  title 'SQL Server must enforce approved authorizations for logical access to information and database-level system resources in accordance with applicable access control policies.'\n  desc 'Authentication with a DoD-approved PKI certificate does not necessarily imply authorization to access the database and all its contents.  To mitigate the risk of unauthorized access to sensitive information by entities that have been issued certificates by DoD-approved PKIs, all DoD systems, including SQL Server databases, must be properly configured to implement access control policies. \n\nSuccessful authentication must not automatically give an entity access to an asset or security boundary. Authorization procedures and controls must be implemented to ensure each authenticated entity also has a validated and current authorization. Authorization is the process of determining whether an entity, once authenticated, is permitted to access a specific asset. Information systems use access control policies and enforcement mechanisms to implement this requirement. \n\nAccess control policies include identity-based policies, role-based policies, and attribute-based policies. Access enforcement mechanisms include access control lists, access control matrices, and cryptography. These policies and mechanisms must be employed by the application to control access between users (or processes acting on behalf of users) and objects (e.g., devices, files, records, processes, programs, and domains) in the information system.\n\nThis requirement is applicable to access control enforcement applications, a category that includes SQL Server.  If SQL Server is not configured to follow applicable policy when approving access, it may be in conflict with networks or other applications in the information system. This may result in users either gaining or being denied access inappropriately and in conflict with applicable policy.'\n  desc 'check', 'Review the system documentation to determine the required levels of protection for securables in the database, by type of user.\n\nReview the permissions actually in place in the database. \n\nThe database permission functions and views provided in the supplemental file Permissions.sql can help with this.\n\nIf the actual permissions do not match the documented requirements, this is a finding.'\n  desc 'fix', 'Use GRANT, REVOKE, DENY, ALTER ROLE … ADD MEMBER … and/or ALTER ROLE …. DROP MEMBER statements to add and remove permissions on database-level securables, bringing them into line with the documented requirements.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67935r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67357'\n  tag rid: 'SV-81847r1_rule'\n  tag stig_id: 'SQL4-00-002000'\n  tag gtitle: 'SRG-APP-000033-DB-000084'\n  tag fix_id: 'F-73469r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000213']\n  tag nist: ['AC-3']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81847.rb"},"title":"SQL Server must enforce approved authorizations for logical access to information and database-level system resources in accordance with applicable access control policies.","desc":"Authentication with a DoD-approved PKI certificate does not necessarily imply authorization to access the database and all its contents.  To mitigate the risk of unauthorized access to sensitive information by entities that have been issued certificates by DoD-approved PKIs, all DoD systems, including SQL Server databases, must be properly configured to implement access control policies. \n\nSuccessful authentication must not automatically give an entity access to an asset or security boundary. Authorization procedures and controls must be implemented to ensure each authenticated entity also has a validated and current authorization. Authorization is the process of determining whether an entity, once authenticated, is permitted to access a specific asset. Information systems use access control policies and enforcement mechanisms to implement this requirement. \n\nAccess control policies include identity-based policies, role-based policies, and attribute-based policies. Access enforcement mechanisms include access control lists, access control matrices, and cryptography. These policies and mechanisms must be employed by the application to control access between users (or processes acting on behalf of users) and objects (e.g., devices, files, records, processes, programs, and domains) in the information system.\n\nThis requirement is applicable to access control enforcement applications, a category that includes SQL Server.  If SQL Server is not configured to follow applicable policy when approving access, it may be in conflict with networks or other applications in the information system. This may result in users either gaining or being denied access inappropriately and in conflict with applicable policy.","descriptions":{"default":"Authentication with a DoD-approved PKI certificate does not necessarily imply authorization to access the database and all its contents.  To mitigate the risk of unauthorized access to sensitive information by entities that have been issued certificates by DoD-approved PKIs, all DoD systems, including SQL Server databases, must be properly configured to implement access control policies. \n\nSuccessful authentication must not automatically give an entity access to an asset or security boundary. Authorization procedures and controls must be implemented to ensure each authenticated entity also has a validated and current authorization. Authorization is the process of determining whether an entity, once authenticated, is permitted to access a specific asset. Information systems use access control policies and enforcement mechanisms to implement this requirement. \n\nAccess control policies include identity-based policies, role-based policies, and attribute-based policies. Access enforcement mechanisms include access control lists, access control matrices, and cryptography. These policies and mechanisms must be employed by the application to control access between users (or processes acting on behalf of users) and objects (e.g., devices, files, records, processes, programs, and domains) in the information system.\n\nThis requirement is applicable to access control enforcement applications, a category that includes SQL Server.  If SQL Server is not configured to follow applicable policy when approving access, it may be in conflict with networks or other applications in the information system. This may result in users either gaining or being denied access inappropriately and in conflict with applicable policy.","check":"Review the system documentation to determine the required levels of protection for securables in the database, by type of user.\n\nReview the permissions actually in place in the database. \n\nThe database permission functions and views provided in the supplemental file Permissions.sql can help with this.\n\nIf the actual permissions do not match the documented requirements, this is a finding.","fix":"Use GRANT, REVOKE, DENY, ALTER ROLE … ADD MEMBER … and/or ALTER ROLE …. DROP MEMBER statements to add and remove permissions on database-level securables, bringing them into line with the documented requirements."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67935r1_chk","severity":"medium","gid":"V-67357","rid":"SV-81847r1_rule","stig_id":"SQL4-00-002000","gtitle":"SRG-APP-000033-DB-000084","fix_id":"F-73469r1_fix","documentable":null,"cci":["CCI-000213"],"nist":["AC-3"]}},{"id":"SV-81849","code":"control 'SV-81849' do\n  title 'SQL Server must generate Trace or Audit records for organization-defined auditable events.'\n  desc 'Audit records can be generated from various components within the information system (e.g., network interface, hard disk, modem, etc.). From an application perspective, certain specific application functionalities may be audited as well.\n\nThe list of audited events is the set of events for which audits are to be generated. This set of events is typically a subset of the list of all events for which the system is capable of generating audit records.  Examples are auditable events, time stamps, source and destination addresses, user/process identifiers, event descriptions, success/fail indications, file names involved, and access control or flow control rules invoked.\n\nOrganizations define which application components shall provide auditable events.\n\nThe DBMS must provide auditing for the list of events defined by the organization or risk negatively impacting forensic investigations into malicious behavior in the information system.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.'\n  desc 'check', %q(If there are no locally-defined security tables or procedures, this is not applicable.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required events are being audited. From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding.\n\nAny additional events locally defined should also be in the list; if not, this is a finding.\n\n14 -- Audit Login\n15 -- Audit Logout\n16 -- Attention\n17 -- ExistingConnection\n18 -- Audit Server Starts and Stops\n20 -- Audit Login Failed\n42 -- SP:Starting\n43 -- SP:Completed\n46 -- Object:Created\n47 -- Object:Deleted\n90 -- User-defined Event\n102 -- Audit Database Scope GDR Event\n103 -- Audit Object GDR Event\n104 -- Audit AddLogin Event\n105 -- Audit Login GDR Event\n106 -- Audit Login Change Property Event\n107 -- Audit Login Change Password Event\n108 -- Audit Add Login to Server Role Event\n109 -- Audit Add DB User Event\n110 -- Audit Add Member to DB Role Event\n111 -- Audit Add Role Event\n112 -- Audit App Role Change Password Event\n113 -- Audit Statement Permission Event\n115 -- Audit Backup/Restore Event\n116 -- Audit DBCC Event\n117 -- Audit Change Audit Event\n118 -- Audit Object Derived Permission Event\n128 -- Audit Database Management Event\n129 -- Audit Database Object Management Event\n130 -- Audit Database Principal Management Event\n131 -- Audit Schema Object Management Event\n132 -- Audit Server Principal Impersonation Event\n133 -- Audit Database Principal Impersonation Event\n134 -- Audit Server Object Take Ownership Event\n135 -- Audit Database Object Take Ownership Event\n152 -- Audit Change Database Owner\n153 -- Audit Schema Object Take Ownership Event\n162 -- User error message\n164 -- Object:Altered\n170 -- Audit Server Scope GDR Event\n171 -- Audit Server Object GDR Event\n172 -- Audit Database Object GDR Event\n173 -- Audit Server Operation Event\n175 -- Audit Server Alter Trace Event\n176 -- Audit Server Object Management Event\n177 -- Audit Server Principal Management Event\n178 -- Audit Database Operation Event\n180 -- Audit Database Object Access Event\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses broad, server-level audit action groups for this purpose. SQL Server Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following code to verify that all configuration-related actions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>');\nGO\n\nExamine the list produced by the query.\n\nIf the audited_result column is not \"SUCCESS AND FAILURE\" on every row, this is a finding.\n\nIf any of the following audit action groups is not included in the list, this is a finding.\n\nAPPLICATION_ROLE_CHANGE_PASSWORD_GROUP\nAUDIT_CHANGE_GROUP\nBACKUP_RESTORE_GROUP\nDATABASE_CHANGE_GROUP\nDATABASE_OBJECT_ACCESS_GROUP\nDATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP\nDATABASE_OBJECT_PERMISSION_CHANGE_GROUP\nDATABASE_OPERATION_GROUP\nDATABASE_OWNERSHIP_CHANGE_GROUP\nDATABASE_PERMISSION_CHANGE_GROUP\nDATABASE_PRINCIPAL_CHANGE_GROUP\nDATABASE_PRINCIPAL_IMPERSONATION_GROUP\nDATABASE_ROLE_MEMBER_CHANGE_GROUP\nDBCC_GROUP\nFAILED_LOGIN_GROUP\nLOGIN_CHANGE_PASSWORD_GROUP\nLOGOUT_GROUP\nSCHEMA_OBJECT_ACCESS_GROUP\nSCHEMA_OBJECT_CHANGE_GROUP\nSCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP\nSCHEMA_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OBJECT_CHANGE_GROUP\nSERVER_OBJECT_OWNERSHIP_CHANGE_GROUP\nSERVER_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OPERATION_GROUP\nSERVER_PERMISSION_CHANGE_GROUP\nSERVER_PRINCIPAL_CHANGE_GROUP\nSERVER_PRINCIPAL_IMPERSONATION_GROUP\nSERVER_ROLE_MEMBER_CHANGE_GROUP\nSERVER_STATE_CHANGE_GROUP\nSUCCESSFUL_LOGIN_GROUP\nTRACE_CHANGE_GROUP)\n  desc 'fix', 'Design and deploy a SQL Server Audit or Trace that captures all auditable events.\n\nThe script provided in the supplemental file Trace.sql can be used to create a trace; edit it as necessary to capture any additional, locally-defined events.\n\nThe script provided in the supplemental file Audit.sql can be used to create an audit; edit it as necessary to capture any additional, locally-defined events.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67937r4_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67359'\n  tag rid: 'SV-81849r2_rule'\n  tag stig_id: 'SQL4-00-011200'\n  tag gtitle: 'SRG-APP-000089-DB-000064'\n  tag fix_id: 'F-73471r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000169']\n  tag nist: ['AU-12 a']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81849.rb"},"title":"SQL Server must generate Trace or Audit records for organization-defined auditable events.","desc":"Audit records can be generated from various components within the information system (e.g., network interface, hard disk, modem, etc.). From an application perspective, certain specific application functionalities may be audited as well.\n\nThe list of audited events is the set of events for which audits are to be generated. This set of events is typically a subset of the list of all events for which the system is capable of generating audit records.  Examples are auditable events, time stamps, source and destination addresses, user/process identifiers, event descriptions, success/fail indications, file names involved, and access control or flow control rules invoked.\n\nOrganizations define which application components shall provide auditable events.\n\nThe DBMS must provide auditing for the list of events defined by the organization or risk negatively impacting forensic investigations into malicious behavior in the information system.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","descriptions":{"default":"Audit records can be generated from various components within the information system (e.g., network interface, hard disk, modem, etc.). From an application perspective, certain specific application functionalities may be audited as well.\n\nThe list of audited events is the set of events for which audits are to be generated. This set of events is typically a subset of the list of all events for which the system is capable of generating audit records.  Examples are auditable events, time stamps, source and destination addresses, user/process identifiers, event descriptions, success/fail indications, file names involved, and access control or flow control rules invoked.\n\nOrganizations define which application components shall provide auditable events.\n\nThe DBMS must provide auditing for the list of events defined by the organization or risk negatively impacting forensic investigations into malicious behavior in the information system.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","check":"If there are no locally-defined security tables or procedures, this is not applicable.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required events are being audited. From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding.\n\nAny additional events locally defined should also be in the list; if not, this is a finding.\n\n14 -- Audit Login\n15 -- Audit Logout\n16 -- Attention\n17 -- ExistingConnection\n18 -- Audit Server Starts and Stops\n20 -- Audit Login Failed\n42 -- SP:Starting\n43 -- SP:Completed\n46 -- Object:Created\n47 -- Object:Deleted\n90 -- User-defined Event\n102 -- Audit Database Scope GDR Event\n103 -- Audit Object GDR Event\n104 -- Audit AddLogin Event\n105 -- Audit Login GDR Event\n106 -- Audit Login Change Property Event\n107 -- Audit Login Change Password Event\n108 -- Audit Add Login to Server Role Event\n109 -- Audit Add DB User Event\n110 -- Audit Add Member to DB Role Event\n111 -- Audit Add Role Event\n112 -- Audit App Role Change Password Event\n113 -- Audit Statement Permission Event\n115 -- Audit Backup/Restore Event\n116 -- Audit DBCC Event\n117 -- Audit Change Audit Event\n118 -- Audit Object Derived Permission Event\n128 -- Audit Database Management Event\n129 -- Audit Database Object Management Event\n130 -- Audit Database Principal Management Event\n131 -- Audit Schema Object Management Event\n132 -- Audit Server Principal Impersonation Event\n133 -- Audit Database Principal Impersonation Event\n134 -- Audit Server Object Take Ownership Event\n135 -- Audit Database Object Take Ownership Event\n152 -- Audit Change Database Owner\n153 -- Audit Schema Object Take Ownership Event\n162 -- User error message\n164 -- Object:Altered\n170 -- Audit Server Scope GDR Event\n171 -- Audit Server Object GDR Event\n172 -- Audit Database Object GDR Event\n173 -- Audit Server Operation Event\n175 -- Audit Server Alter Trace Event\n176 -- Audit Server Object Management Event\n177 -- Audit Server Principal Management Event\n178 -- Audit Database Operation Event\n180 -- Audit Database Object Access Event\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses broad, server-level audit action groups for this purpose. SQL Server Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following code to verify that all configuration-related actions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>');\nGO\n\nExamine the list produced by the query.\n\nIf the audited_result column is not \"SUCCESS AND FAILURE\" on every row, this is a finding.\n\nIf any of the following audit action groups is not included in the list, this is a finding.\n\nAPPLICATION_ROLE_CHANGE_PASSWORD_GROUP\nAUDIT_CHANGE_GROUP\nBACKUP_RESTORE_GROUP\nDATABASE_CHANGE_GROUP\nDATABASE_OBJECT_ACCESS_GROUP\nDATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP\nDATABASE_OBJECT_PERMISSION_CHANGE_GROUP\nDATABASE_OPERATION_GROUP\nDATABASE_OWNERSHIP_CHANGE_GROUP\nDATABASE_PERMISSION_CHANGE_GROUP\nDATABASE_PRINCIPAL_CHANGE_GROUP\nDATABASE_PRINCIPAL_IMPERSONATION_GROUP\nDATABASE_ROLE_MEMBER_CHANGE_GROUP\nDBCC_GROUP\nFAILED_LOGIN_GROUP\nLOGIN_CHANGE_PASSWORD_GROUP\nLOGOUT_GROUP\nSCHEMA_OBJECT_ACCESS_GROUP\nSCHEMA_OBJECT_CHANGE_GROUP\nSCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP\nSCHEMA_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OBJECT_CHANGE_GROUP\nSERVER_OBJECT_OWNERSHIP_CHANGE_GROUP\nSERVER_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OPERATION_GROUP\nSERVER_PERMISSION_CHANGE_GROUP\nSERVER_PRINCIPAL_CHANGE_GROUP\nSERVER_PRINCIPAL_IMPERSONATION_GROUP\nSERVER_ROLE_MEMBER_CHANGE_GROUP\nSERVER_STATE_CHANGE_GROUP\nSUCCESSFUL_LOGIN_GROUP\nTRACE_CHANGE_GROUP","fix":"Design and deploy a SQL Server Audit or Trace that captures all auditable events.\n\nThe script provided in the supplemental file Trace.sql can be used to create a trace; edit it as necessary to capture any additional, locally-defined events.\n\nThe script provided in the supplemental file Audit.sql can be used to create an audit; edit it as necessary to capture any additional, locally-defined events."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67937r4_chk","severity":"medium","gid":"V-67359","rid":"SV-81849r2_rule","stig_id":"SQL4-00-011200","gtitle":"SRG-APP-000089-DB-000064","fix_id":"F-73471r1_fix","documentable":null,"cci":["CCI-000169"],"nist":["AU-12 a"]}},{"id":"SV-81851","code":"control 'SV-81851' do\n  title 'Where SQL Server Audit is in use at the database level, SQL Server must allow only the ISSM (or individuals or roles appointed by the ISSM) to select which auditable events are to be audited at the database level.'\n  desc \"Without the capability to restrict which roles and individuals can select which events are audited, unauthorized personnel may be able to prevent or interfere with the auditing of critical events.\n\nSuppression of auditing could permit an adversary to evade detection.\n\nMisconfigured audits can degrade the system's performance by overwhelming the audit log. Misconfigured audits may also make it more difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nThis version of the requirement deals with SQL Server Audit-based audit trails.\"\n  desc 'check', %q(If SQL Server Audit is not in use at the database level, this is not applicable (NA).\n\nObtain the list of approved audit maintainers from the system documentation.\n\nReview the database roles and individual users that have the following permissions, both of which enable the ability to maintain audit definitions:\nALTER ANY DATABASE AUDIT\nCONTROL ON DATABASE\n\nThe functions and views provided in the supplemental file Permissions.sql can assist in this review.  In the following, \"STIG\" stands for the schema where you have deployed these views and functions.  To see which logins and server roles have been granted these permissions:\n    SELECT\n        *\n    FROM\n        STIG.database_permissions P\n    WHERE\n        (P.[Permission] = 'ALTER ANY DATABASE AUDIT')\n        OR\n        (P.[Permission] = 'CONTROL' AND P.[Securable Type or Class] = 'DATABASE')\n        ;\n\nTo see what users and database roles inherit these permissions from the database roles reported by the previous query, repeat the following for each one:\n    SELECT * FROM STIG.members_of_database_role(<database role name>);\n\nTo see all the permissions in effect for a database principal (server role or login):\n    SELECT * FROM STIG.server_effective_permissions(<principal name>); \n\nIf designated personnel are not able to configure auditable events, this is a finding.\n\nIf unapproved personnel are able to configure auditable events, this is a finding.)\n  desc 'fix', 'Create a database role specifically for audit maintainers, and give it permission to maintain audits, without granting it unnecessary permissions:\nUSE <database name>;\nGO\nCREATE ROLE DATABASE_AUDIT_MAINTAINERS;\nGO\nGRANT ALTER ANY DATABASE AUDIT TO DATABASE_AUDIT_MAINTAINERS;\nGO\n(The role name used here is an example; other names may be used.)\n\nUse REVOKE and/or DENY and/or ALTER ROLE ... DROP MEMBER ... statements to remove the ALTER ANY DATABASE AUDIT permission from all users.\n\nThen, for each authorized database user, run the statement:\nALTER ROLE DATABASE_AUDIT_MAINTAINERS ADD MEMBER <user name> ;\nGO\n\nUse REVOKE and/or DENY and/or ALTER SERVER ROLE ... DROP MEMBER ... statements to remove CONTROL DATABASE permission from logins that do not need it.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67939r2_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67361'\n  tag rid: 'SV-81851r2_rule'\n  tag stig_id: 'SQL4-00-011320'\n  tag gtitle: 'SRG-APP-000090-DB-000065'\n  tag fix_id: 'F-73473r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000171']\n  tag nist: ['AU-12 b']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81851.rb"},"title":"Where SQL Server Audit is in use at the database level, SQL Server must allow only the ISSM (or individuals or roles appointed by the ISSM) to select which auditable events are to be audited at the database level.","desc":"Without the capability to restrict which roles and individuals can select which events are audited, unauthorized personnel may be able to prevent or interfere with the auditing of critical events.\n\nSuppression of auditing could permit an adversary to evade detection.\n\nMisconfigured audits can degrade the system's performance by overwhelming the audit log. Misconfigured audits may also make it more difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nThis version of the requirement deals with SQL Server Audit-based audit trails.","descriptions":{"default":"Without the capability to restrict which roles and individuals can select which events are audited, unauthorized personnel may be able to prevent or interfere with the auditing of critical events.\n\nSuppression of auditing could permit an adversary to evade detection.\n\nMisconfigured audits can degrade the system's performance by overwhelming the audit log. Misconfigured audits may also make it more difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nThis version of the requirement deals with SQL Server Audit-based audit trails.","check":"If SQL Server Audit is not in use at the database level, this is not applicable (NA).\n\nObtain the list of approved audit maintainers from the system documentation.\n\nReview the database roles and individual users that have the following permissions, both of which enable the ability to maintain audit definitions:\nALTER ANY DATABASE AUDIT\nCONTROL ON DATABASE\n\nThe functions and views provided in the supplemental file Permissions.sql can assist in this review.  In the following, \"STIG\" stands for the schema where you have deployed these views and functions.  To see which logins and server roles have been granted these permissions:\n    SELECT\n        *\n    FROM\n        STIG.database_permissions P\n    WHERE\n        (P.[Permission] = 'ALTER ANY DATABASE AUDIT')\n        OR\n        (P.[Permission] = 'CONTROL' AND P.[Securable Type or Class] = 'DATABASE')\n        ;\n\nTo see what users and database roles inherit these permissions from the database roles reported by the previous query, repeat the following for each one:\n    SELECT * FROM STIG.members_of_database_role(<database role name>);\n\nTo see all the permissions in effect for a database principal (server role or login):\n    SELECT * FROM STIG.server_effective_permissions(<principal name>); \n\nIf designated personnel are not able to configure auditable events, this is a finding.\n\nIf unapproved personnel are able to configure auditable events, this is a finding.","fix":"Create a database role specifically for audit maintainers, and give it permission to maintain audits, without granting it unnecessary permissions:\nUSE <database name>;\nGO\nCREATE ROLE DATABASE_AUDIT_MAINTAINERS;\nGO\nGRANT ALTER ANY DATABASE AUDIT TO DATABASE_AUDIT_MAINTAINERS;\nGO\n(The role name used here is an example; other names may be used.)\n\nUse REVOKE and/or DENY and/or ALTER ROLE ... DROP MEMBER ... statements to remove the ALTER ANY DATABASE AUDIT permission from all users.\n\nThen, for each authorized database user, run the statement:\nALTER ROLE DATABASE_AUDIT_MAINTAINERS ADD MEMBER <user name> ;\nGO\n\nUse REVOKE and/or DENY and/or ALTER SERVER ROLE ... DROP MEMBER ... statements to remove CONTROL DATABASE permission from logins that do not need it."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67939r2_chk","severity":"medium","gid":"V-67361","rid":"SV-81851r2_rule","stig_id":"SQL4-00-011320","gtitle":"SRG-APP-000090-DB-000065","fix_id":"F-73473r1_fix","documentable":null,"cci":["CCI-000171"],"nist":["AU-12 b"]}},{"id":"SV-81855","code":"control 'SV-81855' do\n  title 'SQL Server must be monitored to discover unauthorized changes to functions.'\n  desc 'When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Functions, can lead to unauthorized or compromised installations.'\n  desc 'check', \"Check the SQL Server configuration for a timed job that automatically checks all system and user-defined Functions for being modified by running the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent and examine the job from there.)\n\nIf a timed job or some other method is not implemented to check for Functions being modified, this is a finding.\"\n  desc 'fix', 'Configure a SQL Server timed job that automatically checks all system and user-defined Functions for being modified. \n\n(The supplemental file Track.sql, provided with this STIG, can be used to establish a monitoring job.  This should be supplemented with a process for informing the appropriate personnel.  Other techniques for achieving the same ends, such as the use of DDL triggers, are acceptable.)'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67943r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67365'\n  tag rid: 'SV-81855r2_rule'\n  tag stig_id: 'SQL4-00-014900'\n  tag gtitle: 'SRG-APP-000133-DB-000179'\n  tag fix_id: 'F-73477r2_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001499']\n  tag nist: ['CM-5 (6)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81855.rb"},"title":"SQL Server must be monitored to discover unauthorized changes to functions.","desc":"When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Functions, can lead to unauthorized or compromised installations.","descriptions":{"default":"When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Functions, can lead to unauthorized or compromised installations.","check":"Check the SQL Server configuration for a timed job that automatically checks all system and user-defined Functions for being modified by running the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent and examine the job from there.)\n\nIf a timed job or some other method is not implemented to check for Functions being modified, this is a finding.","fix":"Configure a SQL Server timed job that automatically checks all system and user-defined Functions for being modified. \n\n(The supplemental file Track.sql, provided with this STIG, can be used to establish a monitoring job.  This should be supplemented with a process for informing the appropriate personnel.  Other techniques for achieving the same ends, such as the use of DDL triggers, are acceptable.)"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67943r1_chk","severity":"medium","gid":"V-67365","rid":"SV-81855r2_rule","stig_id":"SQL4-00-014900","gtitle":"SRG-APP-000133-DB-000179","fix_id":"F-73477r2_fix","documentable":null,"cci":["CCI-001499"],"nist":["CM-5 (6)"]}},{"id":"SV-81857","code":"control 'SV-81857' do\n  title 'SQL Server must be monitored to discover unauthorized changes to triggers.'\n  desc 'When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Triggers, can lead to unauthorized or compromised installations.'\n  desc 'check', \"Check the SQL Server configuration for the timed job that automatically checks all system and user-defined Triggers for being modified by running the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent and examine the job from there.)\n\nIf such a job, or an alternative method of monitoring triggers for modification, does not exist, this is a finding\"\n  desc 'fix', 'Configure a SQL Server timed job that automatically checks all system and user-defined Triggers for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to establish a monitoring job.  This should be supplemented with a process for informing the appropriate personnel.  Other techniques for achieving the same ends, such as the use of DDL triggers, are acceptable.)'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67945r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67367'\n  tag rid: 'SV-81857r2_rule'\n  tag stig_id: 'SQL4-00-015100'\n  tag gtitle: 'SRG-APP-000133-DB-000179'\n  tag fix_id: 'F-73479r2_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001499']\n  tag nist: ['CM-5 (6)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81857.rb"},"title":"SQL Server must be monitored to discover unauthorized changes to triggers.","desc":"When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Triggers, can lead to unauthorized or compromised installations.","descriptions":{"default":"When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Triggers, can lead to unauthorized or compromised installations.","check":"Check the SQL Server configuration for the timed job that automatically checks all system and user-defined Triggers for being modified by running the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent and examine the job from there.)\n\nIf such a job, or an alternative method of monitoring triggers for modification, does not exist, this is a finding","fix":"Configure a SQL Server timed job that automatically checks all system and user-defined Triggers for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to establish a monitoring job.  This should be supplemented with a process for informing the appropriate personnel.  Other techniques for achieving the same ends, such as the use of DDL triggers, are acceptable.)"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67945r1_chk","severity":"medium","gid":"V-67367","rid":"SV-81857r2_rule","stig_id":"SQL4-00-015100","gtitle":"SRG-APP-000133-DB-000179","fix_id":"F-73479r2_fix","documentable":null,"cci":["CCI-001499"],"nist":["CM-5 (6)"]}},{"id":"SV-81859","code":"control 'SV-81859' do\n  title 'SQL Server must be monitored to discover unauthorized changes to stored procedures.'\n  desc 'When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Stored Procedures, can lead to unauthorized or compromised installations.'\n  desc 'check', \"Check for the existence of a job to monitor for changes to stored procedures:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent and examine the job from there.)\n\nIf such a job, or an alternative method of monitoring stored procedures for modification, does not exist, this is a finding.\"\n  desc 'fix', 'Configure a SQL Server timed job that automatically checks all system and user-defined Stored Procedures for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to establish a monitoring job.  This should be supplemented with a process for informing the appropriate personnel.  Other techniques for achieving the same ends, such as the use of DDL triggers, are acceptable.)'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67947r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67369'\n  tag rid: 'SV-81859r2_rule'\n  tag stig_id: 'SQL4-00-015200'\n  tag gtitle: 'SRG-APP-000133-DB-000179'\n  tag fix_id: 'F-73481r3_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001499']\n  tag nist: ['CM-5 (6)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81859.rb"},"title":"SQL Server must be monitored to discover unauthorized changes to stored procedures.","desc":"When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Stored Procedures, can lead to unauthorized or compromised installations.","descriptions":{"default":"When dealing with change control issues, it should be noted, any changes to the hardware, software, and/or firmware components of SQL Server and/or application can potentially have significant effects on the overall security of the system.\n\nIf SQL Server were to allow any user to make changes to software libraries, then those changes might be implemented without undergoing the appropriate testing and approvals that are part of a robust change management process.\n\nThis requirement is contingent upon the language in which the application is programmed, as many application architectures in use today incorporate their software libraries into, and make them inseparable from, their compiled distributions, rendering them static and version-dependent. However, this requirement does apply to applications with software libraries accessible and configurable, as in the case of interpreted languages.\n\nAccordingly, only qualified and authorized individuals shall be allowed to obtain access to SQL Server components for purposes of initiating changes, including upgrades and modifications.\n\nUnmanaged changes that occur to the SQL Server software libraries or configuration, such as Stored Procedures, can lead to unauthorized or compromised installations.","check":"Check for the existence of a job to monitor for changes to stored procedures:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent and examine the job from there.)\n\nIf such a job, or an alternative method of monitoring stored procedures for modification, does not exist, this is a finding.","fix":"Configure a SQL Server timed job that automatically checks all system and user-defined Stored Procedures for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to establish a monitoring job.  This should be supplemented with a process for informing the appropriate personnel.  Other techniques for achieving the same ends, such as the use of DDL triggers, are acceptable.)"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67947r1_chk","severity":"medium","gid":"V-67369","rid":"SV-81859r2_rule","stig_id":"SQL4-00-015200","gtitle":"SRG-APP-000133-DB-000179","fix_id":"F-73481r3_fix","documentable":null,"cci":["CCI-001499"],"nist":["CM-5 (6)"]}},{"id":"SV-81861","code":"control 'SV-81861' do\n  title 'Database objects (including but not limited to tables, indexes, storage, stored procedures, functions, triggers, links to software external to SQL Server, etc.) must be owned by database/DBMS principals authorized for ownership.'\n  desc \"Within the database, object ownership implies full privileges to the owned object, including the privilege to assign access to the owned objects to other subjects. Database functions and procedures can be coded using definer's rights. This allows anyone who utilizes the object to perform the actions if they were the owner. If not properly managed, this can lead to privileged actions being taken by unauthorized individuals.\n\nConversely, if critical tables or other objects rely on unauthorized owner accounts, these objects may be lost when an account is removed.\"\n  desc 'check', %q(Review system documentation to identify SQL Server accounts authorized to own database objects.\n\nIf the SQL Server database ownership list does not exist or needs to be updated, this is a finding.\n\nThe view STIG.database_permissions, included in the supplemental file, Permissions.sql, can be of use in making this determination:\nUSE <database name>;\nGO\nSELECT DISTINCT\n        S.[Schema/Owner] AS  [Owner],\n        O.[Schema/Owner] AS [Schema],\n        O.[Securable]\nFROM\n        STIG.database_permissions O\n        INNER JOIN STIG.database_permissions S\n                ON S.[Securable] = O.[Schema/Owner]\n                AND O.[Securable Type or Class] = 'OBJECT_OR_COLUMN'\n                AND S.[Securable Type or Class] = 'SCHEMA'\nWHERE\n        S.[Schema/Owner] NOT IN ('dbo', 'sys', 'INFORMATION_SCHEMA' ... )\n        --  Complete the \"NOT IN\" list with the names of user accounts authorized for ownership.\n;\nIf any of the listed owners is not authorized, this is a finding.)\n  desc 'fix', 'Add and/or update system documentation to include any accounts authorized for object ownership and remove any account not authorized.\n\nTo change the schema owning a database object in SQL Server, use this code:\nUSE <database name>;\nGO\nALTER SCHEMA <name of new schema> TRANSFER <name of old schema>.<object name>;\nGO\n\nCaution:  this can break code.  This Fix should be implemented in conjunction with corrections to such code.  Test before deploying in production.  Deploy during a scheduled maintenance window.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67949r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67371'\n  tag rid: 'SV-81861r1_rule'\n  tag stig_id: 'SQL4-00-015600'\n  tag gtitle: 'SRG-APP-000133-DB-000200'\n  tag fix_id: 'F-73483r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001499']\n  tag nist: ['CM-5 (6)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81861.rb"},"title":"Database objects (including but not limited to tables, indexes, storage, stored procedures, functions, triggers, links to software external to SQL Server, etc.) must be owned by database/DBMS principals authorized for ownership.","desc":"Within the database, object ownership implies full privileges to the owned object, including the privilege to assign access to the owned objects to other subjects. Database functions and procedures can be coded using definer's rights. This allows anyone who utilizes the object to perform the actions if they were the owner. If not properly managed, this can lead to privileged actions being taken by unauthorized individuals.\n\nConversely, if critical tables or other objects rely on unauthorized owner accounts, these objects may be lost when an account is removed.","descriptions":{"default":"Within the database, object ownership implies full privileges to the owned object, including the privilege to assign access to the owned objects to other subjects. Database functions and procedures can be coded using definer's rights. This allows anyone who utilizes the object to perform the actions if they were the owner. If not properly managed, this can lead to privileged actions being taken by unauthorized individuals.\n\nConversely, if critical tables or other objects rely on unauthorized owner accounts, these objects may be lost when an account is removed.","check":"Review system documentation to identify SQL Server accounts authorized to own database objects.\n\nIf the SQL Server database ownership list does not exist or needs to be updated, this is a finding.\n\nThe view STIG.database_permissions, included in the supplemental file, Permissions.sql, can be of use in making this determination:\nUSE <database name>;\nGO\nSELECT DISTINCT\n        S.[Schema/Owner] AS  [Owner],\n        O.[Schema/Owner] AS [Schema],\n        O.[Securable]\nFROM\n        STIG.database_permissions O\n        INNER JOIN STIG.database_permissions S\n                ON S.[Securable] = O.[Schema/Owner]\n                AND O.[Securable Type or Class] = 'OBJECT_OR_COLUMN'\n                AND S.[Securable Type or Class] = 'SCHEMA'\nWHERE\n        S.[Schema/Owner] NOT IN ('dbo', 'sys', 'INFORMATION_SCHEMA' ... )\n        --  Complete the \"NOT IN\" list with the names of user accounts authorized for ownership.\n;\nIf any of the listed owners is not authorized, this is a finding.","fix":"Add and/or update system documentation to include any accounts authorized for object ownership and remove any account not authorized.\n\nTo change the schema owning a database object in SQL Server, use this code:\nUSE <database name>;\nGO\nALTER SCHEMA <name of new schema> TRANSFER <name of old schema>.<object name>;\nGO\n\nCaution:  this can break code.  This Fix should be implemented in conjunction with corrections to such code.  Test before deploying in production.  Deploy during a scheduled maintenance window."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67949r1_chk","severity":"medium","gid":"V-67371","rid":"SV-81861r1_rule","stig_id":"SQL4-00-015600","gtitle":"SRG-APP-000133-DB-000200","fix_id":"F-73483r1_fix","documentable":null,"cci":["CCI-001499"],"nist":["CM-5 (6)"]}},{"id":"SV-81863","code":"control 'SV-81863' do\n  title 'In a database owned by a login not having administrative privileges at the instance level, the database property TRUSTWORTHY must be OFF unless required and authorized.'\n  desc \"SQL Server's fixed (built-in) server roles, especially [sysadmin], have powerful capabilities that could cause great harm if misused, so their use must be tightly controlled.\n\nThe SQL Server instance uses each database's TRUSTWORTHY property to guard against tampering that could enable unwarranted privilege escalation. When TRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing resources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits access to other databases (subject to other protections). SQL Server sets TRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY OFF, irrespective of its prior value, when an existing database is attached to it, to address the possibility that an adversary may have tampered with the database, introducing malicious code. To set TRUSTWORTHY ON, an account with the [sysadmin] role must issue an ALTER DATABASE command.\n\nAlthough SQL Server itself treats this property conservatively, application installer programs may set TRUSTWORTHY ON and leave it on. This provides an opportunity for misuse.\n\nWhen TRUSTWORTHY is ON, users of the database can take advantage of the database owner's privileges, by impersonating the owner. This can have particularly serious consequences if the database owner is the [sa] login (which may have been renamed in accordance with SQL4-00-010200, and disabled in accordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS USER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The [sa] login cannot be removed from the [sysadmin] role. The user impersonating [sa] - or another [sysadmin] account - is then able to perform administrative actions across all databases under the instance, including making any himself or any other login a member of [sysadmin].\n\nMost of the other fixed server roles could be similarly abused.\n\nTherefore, TRUSTWORTHY must not be used on databases owned by logins that are members of the fixed server roles. Further, if TRUSTWORTHY is to be used for any other database, the need must be documented and approved.\n\nThe system database [msdb] is an exception: it is required to be TRUSTWORTHY.\"\n  desc 'check', \"If the database is owned by an account that is directly or indirectly a member of a fixed (built-in) server role, this is not applicable (NA).\n\nRun the query:\nUSE <database name>;\nGO\nSELECT\nDB_NAME() AS [Database],\nSUSER_SNAME(D.owner_sid) AS [Database Owner],\nCASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\nAS [Trustworthy]\nFROM\nsys.databases D\nWHERE\nD.[name] = DB_NAME()\nAND DB_NAME() <> 'msdb'\nAND D.is_trustworthy_on = 1;\nGO\nIf the query returns a row indicating that the TRUSTWORTHY setting is OFF, or returns no rows, this is not a finding.\n\nReview the system security plan to determine whether the need for TRUSTWORTHY is documented and approved. If not, this is a finding.\"\n  desc 'fix', 'Run the SQL statements:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67951r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67373'\n  tag rid: 'SV-81863r1_rule'\n  tag stig_id: 'SQL4-00-015620'\n  tag gtitle: 'SRG-APP-000133-DB-000200'\n  tag fix_id: 'F-73485r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001499']\n  tag nist: ['CM-5 (6)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81863.rb"},"title":"In a database owned by a login not having administrative privileges at the instance level, the database property TRUSTWORTHY must be OFF unless required and authorized.","desc":"SQL Server's fixed (built-in) server roles, especially [sysadmin], have powerful capabilities that could cause great harm if misused, so their use must be tightly controlled.\n\nThe SQL Server instance uses each database's TRUSTWORTHY property to guard against tampering that could enable unwarranted privilege escalation. When TRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing resources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits access to other databases (subject to other protections). SQL Server sets TRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY OFF, irrespective of its prior value, when an existing database is attached to it, to address the possibility that an adversary may have tampered with the database, introducing malicious code. To set TRUSTWORTHY ON, an account with the [sysadmin] role must issue an ALTER DATABASE command.\n\nAlthough SQL Server itself treats this property conservatively, application installer programs may set TRUSTWORTHY ON and leave it on. This provides an opportunity for misuse.\n\nWhen TRUSTWORTHY is ON, users of the database can take advantage of the database owner's privileges, by impersonating the owner. This can have particularly serious consequences if the database owner is the [sa] login (which may have been renamed in accordance with SQL4-00-010200, and disabled in accordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS USER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The [sa] login cannot be removed from the [sysadmin] role. The user impersonating [sa] - or another [sysadmin] account - is then able to perform administrative actions across all databases under the instance, including making any himself or any other login a member of [sysadmin].\n\nMost of the other fixed server roles could be similarly abused.\n\nTherefore, TRUSTWORTHY must not be used on databases owned by logins that are members of the fixed server roles. Further, if TRUSTWORTHY is to be used for any other database, the need must be documented and approved.\n\nThe system database [msdb] is an exception: it is required to be TRUSTWORTHY.","descriptions":{"default":"SQL Server's fixed (built-in) server roles, especially [sysadmin], have powerful capabilities that could cause great harm if misused, so their use must be tightly controlled.\n\nThe SQL Server instance uses each database's TRUSTWORTHY property to guard against tampering that could enable unwarranted privilege escalation. When TRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing resources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits access to other databases (subject to other protections). SQL Server sets TRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY OFF, irrespective of its prior value, when an existing database is attached to it, to address the possibility that an adversary may have tampered with the database, introducing malicious code. To set TRUSTWORTHY ON, an account with the [sysadmin] role must issue an ALTER DATABASE command.\n\nAlthough SQL Server itself treats this property conservatively, application installer programs may set TRUSTWORTHY ON and leave it on. This provides an opportunity for misuse.\n\nWhen TRUSTWORTHY is ON, users of the database can take advantage of the database owner's privileges, by impersonating the owner. This can have particularly serious consequences if the database owner is the [sa] login (which may have been renamed in accordance with SQL4-00-010200, and disabled in accordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS USER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The [sa] login cannot be removed from the [sysadmin] role. The user impersonating [sa] - or another [sysadmin] account - is then able to perform administrative actions across all databases under the instance, including making any himself or any other login a member of [sysadmin].\n\nMost of the other fixed server roles could be similarly abused.\n\nTherefore, TRUSTWORTHY must not be used on databases owned by logins that are members of the fixed server roles. Further, if TRUSTWORTHY is to be used for any other database, the need must be documented and approved.\n\nThe system database [msdb] is an exception: it is required to be TRUSTWORTHY.","check":"If the database is owned by an account that is directly or indirectly a member of a fixed (built-in) server role, this is not applicable (NA).\n\nRun the query:\nUSE <database name>;\nGO\nSELECT\nDB_NAME() AS [Database],\nSUSER_SNAME(D.owner_sid) AS [Database Owner],\nCASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\nAS [Trustworthy]\nFROM\nsys.databases D\nWHERE\nD.[name] = DB_NAME()\nAND DB_NAME() <> 'msdb'\nAND D.is_trustworthy_on = 1;\nGO\nIf the query returns a row indicating that the TRUSTWORTHY setting is OFF, or returns no rows, this is not a finding.\n\nReview the system security plan to determine whether the need for TRUSTWORTHY is documented and approved. If not, this is a finding.","fix":"Run the SQL statements:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67951r1_chk","severity":"medium","gid":"V-67373","rid":"SV-81863r1_rule","stig_id":"SQL4-00-015620","gtitle":"SRG-APP-000133-DB-000200","fix_id":"F-73485r1_fix","documentable":null,"cci":["CCI-001499"],"nist":["CM-5 (6)"]}},{"id":"SV-81865","code":"control 'SV-81865' do\n  title 'In a database owned by [sa], or by any other login having administrative privileges at the instance level, the database property TRUSTWORTHY must be OFF.'\n  desc \"SQL Server's fixed (built-in) server roles, especially [sysadmin], have powerful capabilities that could cause great harm if misused, so their use must be tightly controlled.\n\nThe SQL Server instance uses each database's TRUSTWORTHY property to guard against tampering that could enable unwarranted privilege escalation. When TRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing resources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits access to other databases (subject to other protections). SQL Server sets TRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY OFF, irrespective of its prior value, when an existing database is attached to it, to address the possibility that an adversary may have tampered with the database, introducing malicious code. To set TRUSTWORTHY ON, an account with the [sysadmin] role must issue an ALTER DATABASE command.\n\nAlthough SQL Server itself treats this property conservatively, application installer programs may set TRUSTWORTHY ON and leave it on. This provides an opportunity for misuse.\n\nWhen TRUSTWORTHY is ON, users of the database can take advantage of the database owner's privileges, by impersonating the owner. This can have particularly serious consequences if the database owner is the [sa] login (which may have been renamed in accordance with SQL4-00-010200, and disabled in accordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS USER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The [sa] login cannot be removed from the [sysadmin] role. The user impersonating [sa] - or another [sysadmin] account - is then able to perform administrative actions across all databases under the instance, including making any himself or any other login a member of [sysadmin].\n\nMost of the other fixed server roles could be similarly abused.\n\nTherefore, TRUSTWORTHY must not be used on databases owned by logins that are members of the fixed server roles. Further, if TRUSTWORTHY is to be used for any other database, the need must be documented and approved.\n\nThe system database [msdb] is an exception: it is required to be TRUSTWORTHY.\"\n  desc 'check', \"Run the SQL statements:\nUSE <database name>;\nGO\nWITH FixedServerRoles(RoleName) AS\n(\n      SELECT 'sysadmin'\n      UNION SELECT 'securityadmin'\n      UNION SELECT 'serveradmin'\n      UNION SELECT 'setupadmin'\n      UNION SELECT 'processadmin'\n      UNION SELECT 'diskadmin'\n      UNION SELECT 'dbcreator'\n      UNION SELECT 'bulkadmin'\n)\nSELECT\n      DB_NAME() AS [Database],\n      SUSER_SNAME(D.owner_sid) AS [Database Owner],\n      F.RoleName AS [Fixed Server Role],\n      CASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\n            AS [Trustworthy]      \nFROM\n      FixedServerRoles F\n      INNER JOIN sys.databases D ON D.Name = DB_NAME()\nWHERE\n      IS_SRVROLEMEMBER(F.RoleName, SUSER_SNAME(D.owner_sid)) = 1\nAND   DB_NAME() <> 'msdb'\nAND   D.is_trustworthy_on = 1;\nGO\n\nIf the query returns any rows, this is a finding.\"\n  desc 'fix', \"Set the TRUSTWORTHY property OFF; or remove the database owner from the fixed server role(s); or change the database owner.\n\nTo set the TRUSTWORTHY property OFF:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO\nVerify that this produced the intended result by re-running the query specified in the Check.\n\nTo determine the path or paths by which the database owner is assigned the fixed server role or roles, run this query:\n\nUSE <database name>;\nGO\nWITH C AS\n(\nSELECT\n      P.name      AS [Parent Server Role],\n      CAST('Fixed' AS varchar(8))\n                  AS [Server Role Type],\n      M.name      AS [Member],\n      M.type_desc AS [Member Type],\n      P.name      AS [Root],\n      1           AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id = X.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id = X.member_principal_id\nWHERE\n      P.is_fixed_role = 1\nUNION ALL\nSELECT\n      P.name        AS [Parent Server Role],\n      CASE WHEN M.is_fixed_role = 1 THEN CAST('Fixed' AS varchar(8)) ELSE CAST('Custom' AS varchar(8)) END\n                    AS [Server Role Type],\n      M.name        AS [Member],\n      M.type_desc   AS [Member Type],\n      C.[Root]      AS [Root],\n      C.[Level] + 1 AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id = X.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id = X.member_principal_id\n      INNER JOIN C ON P.name = C.Member\n)\n,\nB AS\n(\nSELECT\n      C.[Member] AS [Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nWHERE\n      C.[Member Type] NOT LIKE '%ROLE%'\nUNION ALL\nSELECT\n      B.[Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nINNER JOIN B\n      ON       C.[Member] = B.[Parent Server Role]\n      AND       C.[Level] = B.[Level] - 1\n      AND       C.[Root] = B.[Root]\n)\nSELECT\n      DB_NAME() AS [Database],\n      B.[Leaf]  AS [Owner Login],\n      B.[Root]  AS[Top-Level Server Role],\n      B.[Parent Server Role],\n      B.[Server Role Type],\n      B.[Member],\n      B.[Member Type],\n      B.[Level]\nFROM B\nWHERE B.[Leaf] = (SELECT SUSER_SNAME(D.owner_sid) FROM sys.databases D WHERE D.Name = DB_NAME())\nORDER BY B.[Root], B.[Level], B.[Parent Server Role], B.[Member]\n;\nGO\n\nTo remove the database owner from a fixed server role or a custom server role:\nUSE [master];\nGO\nALTER SERVER ROLE <fixed/custom server role name>\n      DROP MEMBER <database owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query.\n\nTo change the database owner:\nUSE [master];\nGO\nALTER AUTHORIZATION ON DATABASE::<DB name> TO <new owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query.\"\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67953r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67375'\n  tag rid: 'SV-81865r1_rule'\n  tag stig_id: 'SQL4-00-015610'\n  tag gtitle: 'SRG-APP-000133-DB-000200'\n  tag fix_id: 'F-73487r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001499']\n  tag nist: ['CM-5 (6)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81865.rb"},"title":"In a database owned by [sa], or by any other login having administrative privileges at the instance level, the database property TRUSTWORTHY must be OFF.","desc":"SQL Server's fixed (built-in) server roles, especially [sysadmin], have powerful capabilities that could cause great harm if misused, so their use must be tightly controlled.\n\nThe SQL Server instance uses each database's TRUSTWORTHY property to guard against tampering that could enable unwarranted privilege escalation. When TRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing resources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits access to other databases (subject to other protections). SQL Server sets TRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY OFF, irrespective of its prior value, when an existing database is attached to it, to address the possibility that an adversary may have tampered with the database, introducing malicious code. To set TRUSTWORTHY ON, an account with the [sysadmin] role must issue an ALTER DATABASE command.\n\nAlthough SQL Server itself treats this property conservatively, application installer programs may set TRUSTWORTHY ON and leave it on. This provides an opportunity for misuse.\n\nWhen TRUSTWORTHY is ON, users of the database can take advantage of the database owner's privileges, by impersonating the owner. This can have particularly serious consequences if the database owner is the [sa] login (which may have been renamed in accordance with SQL4-00-010200, and disabled in accordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS USER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The [sa] login cannot be removed from the [sysadmin] role. The user impersonating [sa] - or another [sysadmin] account - is then able to perform administrative actions across all databases under the instance, including making any himself or any other login a member of [sysadmin].\n\nMost of the other fixed server roles could be similarly abused.\n\nTherefore, TRUSTWORTHY must not be used on databases owned by logins that are members of the fixed server roles. Further, if TRUSTWORTHY is to be used for any other database, the need must be documented and approved.\n\nThe system database [msdb] is an exception: it is required to be TRUSTWORTHY.","descriptions":{"default":"SQL Server's fixed (built-in) server roles, especially [sysadmin], have powerful capabilities that could cause great harm if misused, so their use must be tightly controlled.\n\nThe SQL Server instance uses each database's TRUSTWORTHY property to guard against tampering that could enable unwarranted privilege escalation. When TRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing resources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits access to other databases (subject to other protections). SQL Server sets TRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY OFF, irrespective of its prior value, when an existing database is attached to it, to address the possibility that an adversary may have tampered with the database, introducing malicious code. To set TRUSTWORTHY ON, an account with the [sysadmin] role must issue an ALTER DATABASE command.\n\nAlthough SQL Server itself treats this property conservatively, application installer programs may set TRUSTWORTHY ON and leave it on. This provides an opportunity for misuse.\n\nWhen TRUSTWORTHY is ON, users of the database can take advantage of the database owner's privileges, by impersonating the owner. This can have particularly serious consequences if the database owner is the [sa] login (which may have been renamed in accordance with SQL4-00-010200, and disabled in accordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS USER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The [sa] login cannot be removed from the [sysadmin] role. The user impersonating [sa] - or another [sysadmin] account - is then able to perform administrative actions across all databases under the instance, including making any himself or any other login a member of [sysadmin].\n\nMost of the other fixed server roles could be similarly abused.\n\nTherefore, TRUSTWORTHY must not be used on databases owned by logins that are members of the fixed server roles. Further, if TRUSTWORTHY is to be used for any other database, the need must be documented and approved.\n\nThe system database [msdb] is an exception: it is required to be TRUSTWORTHY.","check":"Run the SQL statements:\nUSE <database name>;\nGO\nWITH FixedServerRoles(RoleName) AS\n(\n      SELECT 'sysadmin'\n      UNION SELECT 'securityadmin'\n      UNION SELECT 'serveradmin'\n      UNION SELECT 'setupadmin'\n      UNION SELECT 'processadmin'\n      UNION SELECT 'diskadmin'\n      UNION SELECT 'dbcreator'\n      UNION SELECT 'bulkadmin'\n)\nSELECT\n      DB_NAME() AS [Database],\n      SUSER_SNAME(D.owner_sid) AS [Database Owner],\n      F.RoleName AS [Fixed Server Role],\n      CASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\n            AS [Trustworthy]      \nFROM\n      FixedServerRoles F\n      INNER JOIN sys.databases D ON D.Name = DB_NAME()\nWHERE\n      IS_SRVROLEMEMBER(F.RoleName, SUSER_SNAME(D.owner_sid)) = 1\nAND   DB_NAME() <> 'msdb'\nAND   D.is_trustworthy_on = 1;\nGO\n\nIf the query returns any rows, this is a finding.","fix":"Set the TRUSTWORTHY property OFF; or remove the database owner from the fixed server role(s); or change the database owner.\n\nTo set the TRUSTWORTHY property OFF:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO\nVerify that this produced the intended result by re-running the query specified in the Check.\n\nTo determine the path or paths by which the database owner is assigned the fixed server role or roles, run this query:\n\nUSE <database name>;\nGO\nWITH C AS\n(\nSELECT\n      P.name      AS [Parent Server Role],\n      CAST('Fixed' AS varchar(8))\n                  AS [Server Role Type],\n      M.name      AS [Member],\n      M.type_desc AS [Member Type],\n      P.name      AS [Root],\n      1           AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id = X.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id = X.member_principal_id\nWHERE\n      P.is_fixed_role = 1\nUNION ALL\nSELECT\n      P.name        AS [Parent Server Role],\n      CASE WHEN M.is_fixed_role = 1 THEN CAST('Fixed' AS varchar(8)) ELSE CAST('Custom' AS varchar(8)) END\n                    AS [Server Role Type],\n      M.name        AS [Member],\n      M.type_desc   AS [Member Type],\n      C.[Root]      AS [Root],\n      C.[Level] + 1 AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id = X.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id = X.member_principal_id\n      INNER JOIN C ON P.name = C.Member\n)\n,\nB AS\n(\nSELECT\n      C.[Member] AS [Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nWHERE\n      C.[Member Type] NOT LIKE '%ROLE%'\nUNION ALL\nSELECT\n      B.[Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nINNER JOIN B\n      ON       C.[Member] = B.[Parent Server Role]\n      AND       C.[Level] = B.[Level] - 1\n      AND       C.[Root] = B.[Root]\n)\nSELECT\n      DB_NAME() AS [Database],\n      B.[Leaf]  AS [Owner Login],\n      B.[Root]  AS[Top-Level Server Role],\n      B.[Parent Server Role],\n      B.[Server Role Type],\n      B.[Member],\n      B.[Member Type],\n      B.[Level]\nFROM B\nWHERE B.[Leaf] = (SELECT SUSER_SNAME(D.owner_sid) FROM sys.databases D WHERE D.Name = DB_NAME())\nORDER BY B.[Root], B.[Level], B.[Parent Server Role], B.[Member]\n;\nGO\n\nTo remove the database owner from a fixed server role or a custom server role:\nUSE [master];\nGO\nALTER SERVER ROLE <fixed/custom server role name>\n      DROP MEMBER <database owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query.\n\nTo change the database owner:\nUSE [master];\nGO\nALTER AUTHORIZATION ON DATABASE::<DB name> TO <new owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67953r1_chk","severity":"medium","gid":"V-67375","rid":"SV-81865r1_rule","stig_id":"SQL4-00-015610","gtitle":"SRG-APP-000133-DB-000200","fix_id":"F-73487r1_fix","documentable":null,"cci":["CCI-001499"],"nist":["CM-5 (6)"]}},{"id":"SV-81867","code":"control 'SV-81867' do\n  title 'In the event of a system failure, SQL Server must preserve any information necessary to return to operations with least disruption to mission processes.'\n  desc 'Failure to a known state can address safety or security in accordance with the mission/business needs of the organization. The existence and reliability of database backups is an essential aspect of the ability to fail to a known state. It helps prevent a loss of confidentiality, integrity, or availability in the event of a failure of the information system or a component of the system.\n\nBackups must be performed according to an appropriate schedule, and must be tested periodically to provide assurance that they can be used for restoring the database.'\n  desc 'check', 'Review the system security plan (SSP) to determine whether the database is static, the recovery model to be used, the backup schedule, and the plan for testing database restoration.  If the SSP does not state that the database is static, assume that it is not static.  If any of the other information is absent, this is a finding.\n\nIf the database is not static, but the documented recovery model is Simple, this is a finding.\n\nIf the database is not static, and the documented recovery model is Bulk Logged, but the justification and authorization for this are not documented, this is a finding.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of the database; select Properties.  Select the Options page.\n\nObserve the Recovery Model field, near the top of the page.  If this does not match the documented recovery model, this is a finding.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.\n\nReview the jobs set up to implement the backup plan.  If they are absent, this is a finding.\n\nRight-click on each backup job; select View History.  If the history indicates a pattern of job failures, this is a finding.\n\nReview evidence that database recovery is tested annually or more often, and that the most recent test was successful.  If not, this is a finding.'\n  desc 'fix', 'Modify the system security plan, to include whether the database is static, the correct recovery model to be used, the backup schedule, and the plan for testing database restoration.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of the database; select Properties.  Select the Options page.  Set the Recovery Model field, near the top of the page, to the correct value.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.  Create, modify and delete jobs to implement the backup schedule.   (Alternatively, this may done using T-SQL code.)\n\nCorrect any issues that have been causing backups to fail.\n\nTest the restoration of the database at least once a year; correct any issues that cause it to fail.  Maintain a record of these tests.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67955r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67377'\n  tag rid: 'SV-81867r2_rule'\n  tag stig_id: 'SQL4-00-021210'\n  tag gtitle: 'SRG-APP-000226-DB-000147'\n  tag fix_id: 'F-73489r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001665']\n  tag nist: ['SC-24']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81867.rb"},"title":"In the event of a system failure, SQL Server must preserve any information necessary to return to operations with least disruption to mission processes.","desc":"Failure to a known state can address safety or security in accordance with the mission/business needs of the organization. The existence and reliability of database backups is an essential aspect of the ability to fail to a known state. It helps prevent a loss of confidentiality, integrity, or availability in the event of a failure of the information system or a component of the system.\n\nBackups must be performed according to an appropriate schedule, and must be tested periodically to provide assurance that they can be used for restoring the database.","descriptions":{"default":"Failure to a known state can address safety or security in accordance with the mission/business needs of the organization. The existence and reliability of database backups is an essential aspect of the ability to fail to a known state. It helps prevent a loss of confidentiality, integrity, or availability in the event of a failure of the information system or a component of the system.\n\nBackups must be performed according to an appropriate schedule, and must be tested periodically to provide assurance that they can be used for restoring the database.","check":"Review the system security plan (SSP) to determine whether the database is static, the recovery model to be used, the backup schedule, and the plan for testing database restoration.  If the SSP does not state that the database is static, assume that it is not static.  If any of the other information is absent, this is a finding.\n\nIf the database is not static, but the documented recovery model is Simple, this is a finding.\n\nIf the database is not static, and the documented recovery model is Bulk Logged, but the justification and authorization for this are not documented, this is a finding.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of the database; select Properties.  Select the Options page.\n\nObserve the Recovery Model field, near the top of the page.  If this does not match the documented recovery model, this is a finding.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.\n\nReview the jobs set up to implement the backup plan.  If they are absent, this is a finding.\n\nRight-click on each backup job; select View History.  If the history indicates a pattern of job failures, this is a finding.\n\nReview evidence that database recovery is tested annually or more often, and that the most recent test was successful.  If not, this is a finding.","fix":"Modify the system security plan, to include whether the database is static, the correct recovery model to be used, the backup schedule, and the plan for testing database restoration.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of the database; select Properties.  Select the Options page.  Set the Recovery Model field, near the top of the page, to the correct value.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.  Create, modify and delete jobs to implement the backup schedule.   (Alternatively, this may done using T-SQL code.)\n\nCorrect any issues that have been causing backups to fail.\n\nTest the restoration of the database at least once a year; correct any issues that cause it to fail.  Maintain a record of these tests."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67955r1_chk","severity":"medium","gid":"V-67377","rid":"SV-81867r2_rule","stig_id":"SQL4-00-021210","gtitle":"SRG-APP-000226-DB-000147","fix_id":"F-73489r1_fix","documentable":null,"cci":["CCI-001665"],"nist":["SC-24"]}},{"id":"SV-81871","code":"control 'SV-81871' do\n  title 'The Database Master Key must be encrypted by the Service Master Key, where a Database Master Key is required and another encryption method has not been specified.'\n  desc 'When not encrypted by the Service Master Key, system administrators or application administrators may access and use the Database Master Key to view sensitive data that they are not authorized to view. Where alternate encryption means are not feasible, encryption by the Service Master Key may be necessary. To help protect sensitive data from unauthorized access by DBAs, mitigations may be in order. Mitigations may include automatic alerts or other audit events when the Database Master Key is accessed outside of the application or by a DBA account.'\n  desc 'check', 'If no databases require encryption, this is not a finding.\n\nFrom the query prompt:\nSELECT name\nFROM [master].sys.databases\nWHERE is_master_key_encrypted_by_server = 1\nAND owner_sid <> 1\nAND state = 0;\n(Note that this query assumes that the [sa] account is not used as the owner of application databases, in keeping with other STIG guidance.  If this is not the case, modify the query accordingly.)\n\nIf no databases are returned by the query, this is not a finding.\n\nFor any databases returned, verify in the System Security Plan that encryption of the Database Master Key using the Service Master Key is acceptable and approved by the Information Owner, and the encrypted data does not require additional protections to deter or detect DBA access. If not approved, this is a finding.\n\nIf approved and additional protections are required, then verify the additional requirements are in place in accordance with the System Security Plan. These may include additional auditing on access of the Database Master Key with alerts or other automated monitoring.\n\nIf the additional requirements are not in place, this is a finding.'\n  desc 'fix', 'Where possible, encrypt the Database Master Key with a password known only to the application administrator.  Where not possible, configure additional audit events or alerts to detect unauthorized access to the Database Master Key by users not authorized to view sensitive data.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67959r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67381'\n  tag rid: 'SV-81871r1_rule'\n  tag stig_id: 'SQL4-00-024100'\n  tag gtitle: 'SRG-APP-000231-DB-000154'\n  tag fix_id: 'F-73493r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001199']\n  tag nist: ['SC-28']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81871.rb"},"title":"The Database Master Key must be encrypted by the Service Master Key, where a Database Master Key is required and another encryption method has not been specified.","desc":"When not encrypted by the Service Master Key, system administrators or application administrators may access and use the Database Master Key to view sensitive data that they are not authorized to view. Where alternate encryption means are not feasible, encryption by the Service Master Key may be necessary. To help protect sensitive data from unauthorized access by DBAs, mitigations may be in order. Mitigations may include automatic alerts or other audit events when the Database Master Key is accessed outside of the application or by a DBA account.","descriptions":{"default":"When not encrypted by the Service Master Key, system administrators or application administrators may access and use the Database Master Key to view sensitive data that they are not authorized to view. Where alternate encryption means are not feasible, encryption by the Service Master Key may be necessary. To help protect sensitive data from unauthorized access by DBAs, mitigations may be in order. Mitigations may include automatic alerts or other audit events when the Database Master Key is accessed outside of the application or by a DBA account.","check":"If no databases require encryption, this is not a finding.\n\nFrom the query prompt:\nSELECT name\nFROM [master].sys.databases\nWHERE is_master_key_encrypted_by_server = 1\nAND owner_sid <> 1\nAND state = 0;\n(Note that this query assumes that the [sa] account is not used as the owner of application databases, in keeping with other STIG guidance.  If this is not the case, modify the query accordingly.)\n\nIf no databases are returned by the query, this is not a finding.\n\nFor any databases returned, verify in the System Security Plan that encryption of the Database Master Key using the Service Master Key is acceptable and approved by the Information Owner, and the encrypted data does not require additional protections to deter or detect DBA access. If not approved, this is a finding.\n\nIf approved and additional protections are required, then verify the additional requirements are in place in accordance with the System Security Plan. These may include additional auditing on access of the Database Master Key with alerts or other automated monitoring.\n\nIf the additional requirements are not in place, this is a finding.","fix":"Where possible, encrypt the Database Master Key with a password known only to the application administrator.  Where not possible, configure additional audit events or alerts to detect unauthorized access to the Database Master Key by users not authorized to view sensitive data."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67959r1_chk","severity":"medium","gid":"V-67381","rid":"SV-81871r1_rule","stig_id":"SQL4-00-024100","gtitle":"SRG-APP-000231-DB-000154","fix_id":"F-73493r1_fix","documentable":null,"cci":["CCI-001199"],"nist":["SC-28"]}},{"id":"SV-81873","code":"control 'SV-81873' do\n  title 'Database Master Key passwords must not be stored in credentials within the database.'\n  desc 'Storage of the Database Master Key password in a database credential allows decryption of sensitive data by privileged users who may not have a need-to-know requirement to access the data.'\n  desc 'check', 'From the query prompt:\nSELECT COUNT(credential_id)\nFROM [master].sys.master_key_passwords\n\nIf count is not 0, this is a finding.'\n  desc 'fix', \"Use the stored procedure sp_control_dbmasterkey_password to remove any credentials that\nstore Database Master Key passwords.\nFrom the query prompt:\nEXEC SP_CONTROL_DBMASTERKEY_PASSWORD @db_name = '<database name>', @action\n= N'drop'\"\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67961r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67383'\n  tag rid: 'SV-81873r1_rule'\n  tag stig_id: 'SQL4-00-024200'\n  tag gtitle: 'SRG-APP-000231-DB-000154'\n  tag fix_id: 'F-73495r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001199']\n  tag nist: ['SC-28']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81873.rb"},"title":"Database Master Key passwords must not be stored in credentials within the database.","desc":"Storage of the Database Master Key password in a database credential allows decryption of sensitive data by privileged users who may not have a need-to-know requirement to access the data.","descriptions":{"default":"Storage of the Database Master Key password in a database credential allows decryption of sensitive data by privileged users who may not have a need-to-know requirement to access the data.","check":"From the query prompt:\nSELECT COUNT(credential_id)\nFROM [master].sys.master_key_passwords\n\nIf count is not 0, this is a finding.","fix":"Use the stored procedure sp_control_dbmasterkey_password to remove any credentials that\nstore Database Master Key passwords.\nFrom the query prompt:\nEXEC SP_CONTROL_DBMASTERKEY_PASSWORD @db_name = '<database name>', @action\n= N'drop'"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67961r1_chk","severity":"medium","gid":"V-67383","rid":"SV-81873r1_rule","stig_id":"SQL4-00-024200","gtitle":"SRG-APP-000231-DB-000154","fix_id":"F-73495r1_fix","documentable":null,"cci":["CCI-001199"],"nist":["SC-28"]}},{"id":"SV-81875","code":"control 'SV-81875' do\n  title 'Symmetric keys (other than the database master key) must use a DoD certificate to encrypt the key.'\n  desc 'Data within the database is protected by use of encryption. The symmetric keys are critical for this process. If the symmetric keys were to be compromised the data could be disclosed to unauthorized personnel.\n\nThe database master key is exempt, as a password must be supplied when creating it.'\n  desc 'check', \"In a query tool:\nUSE <database name>;\nGO\nSELECT s.name, k.crypt_type_desc\nFROM sys.symmetric_keys s, sys.key_encryptions k\nWHERE s.symmetric_key_id = k.key_id\nAND s.name <> '##MS_DatabaseMasterKey##'\nAND k.crypt_type IN ('ESKP', 'ESKS')\nORDER BY s.name, k.crypt_type_desc;\nGO\n\nReview any symmetric keys that have been defined against the System Security Plan.\n\nIf any keys are defined that are not documented in the System Security Plan, this is a finding.\n\nReview the System Security Plan to review the encryption mechanism specified for each symmetric key. If the method does not indicate use of certificates, this is a finding.\n\nIf the certificate specified is not a DoD PKI certificate, this is a finding.\"\n  desc 'fix', 'Configure or alter symmetric keys to encrypt keys with certificates or authorized asymmetric keys.\nIn a query tool:\n     ALTER SYMMETRIC KEY <key name> ADD ENCRYPTION BY CERTIFICATE <certificate name>;\n     ALTER SYMMETRIC KEY <key name> DROP ENCRYPTION BY <password, symmetric key or asymmetric key>;\n\nThe symmetric key must specify a certificate or asymmetric key for encryption.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67963r2_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67385'\n  tag rid: 'SV-81875r2_rule'\n  tag stig_id: 'SQL4-00-024300'\n  tag gtitle: 'SRG-APP-000231-DB-000154'\n  tag fix_id: 'F-73497r2_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001199']\n  tag nist: ['SC-28']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81875.rb"},"title":"Symmetric keys (other than the database master key) must use a DoD certificate to encrypt the key.","desc":"Data within the database is protected by use of encryption. The symmetric keys are critical for this process. If the symmetric keys were to be compromised the data could be disclosed to unauthorized personnel.\n\nThe database master key is exempt, as a password must be supplied when creating it.","descriptions":{"default":"Data within the database is protected by use of encryption. The symmetric keys are critical for this process. If the symmetric keys were to be compromised the data could be disclosed to unauthorized personnel.\n\nThe database master key is exempt, as a password must be supplied when creating it.","check":"In a query tool:\nUSE <database name>;\nGO\nSELECT s.name, k.crypt_type_desc\nFROM sys.symmetric_keys s, sys.key_encryptions k\nWHERE s.symmetric_key_id = k.key_id\nAND s.name <> '##MS_DatabaseMasterKey##'\nAND k.crypt_type IN ('ESKP', 'ESKS')\nORDER BY s.name, k.crypt_type_desc;\nGO\n\nReview any symmetric keys that have been defined against the System Security Plan.\n\nIf any keys are defined that are not documented in the System Security Plan, this is a finding.\n\nReview the System Security Plan to review the encryption mechanism specified for each symmetric key. If the method does not indicate use of certificates, this is a finding.\n\nIf the certificate specified is not a DoD PKI certificate, this is a finding.","fix":"Configure or alter symmetric keys to encrypt keys with certificates or authorized asymmetric keys.\nIn a query tool:\n     ALTER SYMMETRIC KEY <key name> ADD ENCRYPTION BY CERTIFICATE <certificate name>;\n     ALTER SYMMETRIC KEY <key name> DROP ENCRYPTION BY <password, symmetric key or asymmetric key>;\n\nThe symmetric key must specify a certificate or asymmetric key for encryption."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67963r2_chk","severity":"medium","gid":"V-67385","rid":"SV-81875r2_rule","stig_id":"SQL4-00-024300","gtitle":"SRG-APP-000231-DB-000154","fix_id":"F-73497r2_fix","documentable":null,"cci":["CCI-001199"],"nist":["SC-28"]}},{"id":"SV-81879","code":"control 'SV-81879' do\n  title 'Database contents must be protected from unauthorized and unintended information transfer by enforcement of a data-transfer policy.'\n  desc 'The purpose of this control is to prevent information, including encrypted representations of information, produced by the actions of a prior user/role (or the actions of a process acting on behalf of a prior user/role) from being available to any current user/role (or current process) that obtains access to a shared system resource (e.g., registers, main memory, secondary storage) after the resource has been released back to the information system. Control of information in shared resources is also referred to as object reuse.\n\nData used for the development and testing of applications often involves copying data from production. It is important that specific procedures exist for this process, so copies of sensitive data are not misplaced or left in a temporary location without the proper controls.'\n  desc 'check', 'Verify there are proper procedures in place for the transfer of development/test data from production. Review any scripts or code that exists for the movement of production data to development/test and verify copies of production data are not left in unprotected locations.\n\nIf there is no documented procedure for data movement from production to development/test, this is a finding.\n\nIf data movement code that copies from production to development/test does exist and leaves any copies of production data in unprotected locations, this is a finding.'\n  desc 'fix', 'Create and document a process for moving data from production to development/test systems and follow the process.\n\nModify any code used for moving data from production to development/test systems to ensure copies of production data are not left in unsecured locations.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67967r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67389'\n  tag rid: 'SV-81879r1_rule'\n  tag stig_id: 'SQL4-00-021800'\n  tag gtitle: 'SRG-APP-000243-DB-000128'\n  tag fix_id: 'F-73501r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001090']\n  tag nist: ['SC-4']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81879.rb"},"title":"Database contents must be protected from unauthorized and unintended information transfer by enforcement of a data-transfer policy.","desc":"The purpose of this control is to prevent information, including encrypted representations of information, produced by the actions of a prior user/role (or the actions of a process acting on behalf of a prior user/role) from being available to any current user/role (or current process) that obtains access to a shared system resource (e.g., registers, main memory, secondary storage) after the resource has been released back to the information system. Control of information in shared resources is also referred to as object reuse.\n\nData used for the development and testing of applications often involves copying data from production. It is important that specific procedures exist for this process, so copies of sensitive data are not misplaced or left in a temporary location without the proper controls.","descriptions":{"default":"The purpose of this control is to prevent information, including encrypted representations of information, produced by the actions of a prior user/role (or the actions of a process acting on behalf of a prior user/role) from being available to any current user/role (or current process) that obtains access to a shared system resource (e.g., registers, main memory, secondary storage) after the resource has been released back to the information system. Control of information in shared resources is also referred to as object reuse.\n\nData used for the development and testing of applications often involves copying data from production. It is important that specific procedures exist for this process, so copies of sensitive data are not misplaced or left in a temporary location without the proper controls.","check":"Verify there are proper procedures in place for the transfer of development/test data from production. Review any scripts or code that exists for the movement of production data to development/test and verify copies of production data are not left in unprotected locations.\n\nIf there is no documented procedure for data movement from production to development/test, this is a finding.\n\nIf data movement code that copies from production to development/test does exist and leaves any copies of production data in unprotected locations, this is a finding.","fix":"Create and document a process for moving data from production to development/test systems and follow the process.\n\nModify any code used for moving data from production to development/test systems to ensure copies of production data are not left in unsecured locations."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67967r1_chk","severity":"medium","gid":"V-67389","rid":"SV-81879r1_rule","stig_id":"SQL4-00-021800","gtitle":"SRG-APP-000243-DB-000128","fix_id":"F-73501r1_fix","documentable":null,"cci":["CCI-001090"],"nist":["SC-4"]}},{"id":"SV-81881","code":"control 'SV-81881' do\n  title 'SQL Server must check the validity of all data inputs except those specifically identified by the organization.'\n  desc 'Invalid user input occurs when a user inserts data or characters into an application’s data entry fields and the application is unprepared to process that data. This results in unanticipated application behavior potentially leading to an application or information system compromise. Invalid user input is one of the primary methods employed when attempting to compromise an application.\n\nSQL Server needs to validate the data user’s attempt to input to the application for processing. Rules for checking the valid syntax and semantics of information system inputs (e.g., character set, length, numerical range, acceptable values) are in place to verify inputs match specified definitions for format and content. Inputs passed to interpreters are prescreened to prevent the content from being unintentionally interpreted as commands.\n\nA poorly designed database system can have many problems. A common issue with these types of systems is the missed opportunity to use constraints.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.'\n  desc 'check', 'Review DBMS code (stored procedures, functions, triggers), application code, settings, column and field definitions, and constraints to determine whether the database is protected against invalid input.\n\nIf code exists that allows invalid data to be acted upon or input into the database, this is a finding.\n\nIf column/field definitions are not reflective of the data, this is a finding.\n\nIf columns/fields do not contain constraints and validity checking where required, this is a finding.\n\nWhere a column/field is noted in the system documentation as necessarily free-form, even though its name and context suggest that it should be strongly typed and constrained, the absence of these protections is not a finding.\n\nWhere a column/field is clearly identified by name, caption or context as Notes, Comments, Description, Text, etc., the absence of these protections is not a finding.'\n  desc 'fix', 'Use triggers, constraints, foreign keys, etc. to validate data input.\n\nModify SQL Server to properly use the correct column data types as required in the database.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67969r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67391'\n  tag rid: 'SV-81881r2_rule'\n  tag stig_id: 'SQL4-00-022500'\n  tag gtitle: 'SRG-APP-000251-DB-000160'\n  tag fix_id: 'F-73503r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001310']\n  tag nist: ['SI-10']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81881.rb"},"title":"SQL Server must check the validity of all data inputs except those specifically identified by the organization.","desc":"Invalid user input occurs when a user inserts data or characters into an application’s data entry fields and the application is unprepared to process that data. This results in unanticipated application behavior potentially leading to an application or information system compromise. Invalid user input is one of the primary methods employed when attempting to compromise an application.\n\nSQL Server needs to validate the data user’s attempt to input to the application for processing. Rules for checking the valid syntax and semantics of information system inputs (e.g., character set, length, numerical range, acceptable values) are in place to verify inputs match specified definitions for format and content. Inputs passed to interpreters are prescreened to prevent the content from being unintentionally interpreted as commands.\n\nA poorly designed database system can have many problems. A common issue with these types of systems is the missed opportunity to use constraints.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","descriptions":{"default":"Invalid user input occurs when a user inserts data or characters into an application’s data entry fields and the application is unprepared to process that data. This results in unanticipated application behavior potentially leading to an application or information system compromise. Invalid user input is one of the primary methods employed when attempting to compromise an application.\n\nSQL Server needs to validate the data user’s attempt to input to the application for processing. Rules for checking the valid syntax and semantics of information system inputs (e.g., character set, length, numerical range, acceptable values) are in place to verify inputs match specified definitions for format and content. Inputs passed to interpreters are prescreened to prevent the content from being unintentionally interpreted as commands.\n\nA poorly designed database system can have many problems. A common issue with these types of systems is the missed opportunity to use constraints.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","check":"Review DBMS code (stored procedures, functions, triggers), application code, settings, column and field definitions, and constraints to determine whether the database is protected against invalid input.\n\nIf code exists that allows invalid data to be acted upon or input into the database, this is a finding.\n\nIf column/field definitions are not reflective of the data, this is a finding.\n\nIf columns/fields do not contain constraints and validity checking where required, this is a finding.\n\nWhere a column/field is noted in the system documentation as necessarily free-form, even though its name and context suggest that it should be strongly typed and constrained, the absence of these protections is not a finding.\n\nWhere a column/field is clearly identified by name, caption or context as Notes, Comments, Description, Text, etc., the absence of these protections is not a finding.","fix":"Use triggers, constraints, foreign keys, etc. to validate data input.\n\nModify SQL Server to properly use the correct column data types as required in the database."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67969r1_chk","severity":"medium","gid":"V-67391","rid":"SV-81881r2_rule","stig_id":"SQL4-00-022500","gtitle":"SRG-APP-000251-DB-000160","fix_id":"F-73503r1_fix","documentable":null,"cci":["CCI-001310"],"nist":["SI-10"]}},{"id":"SV-81883","code":"control 'SV-81883' do\n  title 'The DBMS and associated applications must reserve the use of dynamic code execution for situations that require it.'\n  desc 'With respect to database management systems, one class of threat is known as SQL Injection, or more generally, code injection. It takes advantage of the dynamic execution capabilities of various programming languages, including dialects of SQL. In such cases, the attacker deduces the manner in which SQL statements are being processed, either from inside knowledge or by observing system behavior in response to invalid inputs. When the attacker identifies scenarios where SQL queries are being assembled by application code (which may be within the database or separate from it) and executed dynamically, the attacker is then able to craft input strings that subvert the intent of the query. Potentially, the attacker can gain unauthorized access to data, including security settings, and severely corrupt or destroy the database.\n\nThe principal protection against code injection is not to use dynamic execution except where it provides necessary functionality that cannot be utilized otherwise. Use strongly typed data items rather than general-purpose strings as input parameters to task-specific, pre-compiled stored procedures and functions (and triggers).\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered'\n  desc 'check', 'Review source code in the database (stored procedures, functions, triggers) and application source code, to identify cases of dynamic code execution.\n\nIf dynamic code execution is employed in circumstances where the objective could practically be satisfied by static execution with strongly typed parameters, this is a finding.'\n  desc 'fix', 'Where dynamic code execution is employed in circumstances where the objective could practically be satisfied by static execution with strongly typed parameters, modify the code to do so.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67971r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67393'\n  tag rid: 'SV-81883r2_rule'\n  tag stig_id: 'SQL4-00-031500'\n  tag gtitle: 'SRG-APP-000251-DB-000391'\n  tag fix_id: 'F-73505r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001310']\n  tag nist: ['SI-10']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81883.rb"},"title":"The DBMS and associated applications must reserve the use of dynamic code execution for situations that require it.","desc":"With respect to database management systems, one class of threat is known as SQL Injection, or more generally, code injection. It takes advantage of the dynamic execution capabilities of various programming languages, including dialects of SQL. In such cases, the attacker deduces the manner in which SQL statements are being processed, either from inside knowledge or by observing system behavior in response to invalid inputs. When the attacker identifies scenarios where SQL queries are being assembled by application code (which may be within the database or separate from it) and executed dynamically, the attacker is then able to craft input strings that subvert the intent of the query. Potentially, the attacker can gain unauthorized access to data, including security settings, and severely corrupt or destroy the database.\n\nThe principal protection against code injection is not to use dynamic execution except where it provides necessary functionality that cannot be utilized otherwise. Use strongly typed data items rather than general-purpose strings as input parameters to task-specific, pre-compiled stored procedures and functions (and triggers).\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered","descriptions":{"default":"With respect to database management systems, one class of threat is known as SQL Injection, or more generally, code injection. It takes advantage of the dynamic execution capabilities of various programming languages, including dialects of SQL. In such cases, the attacker deduces the manner in which SQL statements are being processed, either from inside knowledge or by observing system behavior in response to invalid inputs. When the attacker identifies scenarios where SQL queries are being assembled by application code (which may be within the database or separate from it) and executed dynamically, the attacker is then able to craft input strings that subvert the intent of the query. Potentially, the attacker can gain unauthorized access to data, including security settings, and severely corrupt or destroy the database.\n\nThe principal protection against code injection is not to use dynamic execution except where it provides necessary functionality that cannot be utilized otherwise. Use strongly typed data items rather than general-purpose strings as input parameters to task-specific, pre-compiled stored procedures and functions (and triggers).\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered","check":"Review source code in the database (stored procedures, functions, triggers) and application source code, to identify cases of dynamic code execution.\n\nIf dynamic code execution is employed in circumstances where the objective could practically be satisfied by static execution with strongly typed parameters, this is a finding.","fix":"Where dynamic code execution is employed in circumstances where the objective could practically be satisfied by static execution with strongly typed parameters, modify the code to do so."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67971r1_chk","severity":"medium","gid":"V-67393","rid":"SV-81883r2_rule","stig_id":"SQL4-00-031500","gtitle":"SRG-APP-000251-DB-000391","fix_id":"F-73505r1_fix","documentable":null,"cci":["CCI-001310"],"nist":["SI-10"]}},{"id":"SV-81885","code":"control 'SV-81885' do\n  title 'The DBMS and associated applications, when making use of dynamic code execution, must scan input data for invalid values that may indicate a code injection attack.'\n  desc \"With respect to database management systems, one class of threat is known as SQL Injection, or more generally, code injection. It takes advantage of the dynamic execution capabilities of various programming languages, including dialects of SQL. In such cases, the attacker deduces the manner in which SQL statements are being processed, either from inside knowledge or by observing system behavior in response to invalid inputs. When the attacker identifies scenarios where SQL queries are being assembled by application code (which may be within the database or separate from it) and executed dynamically, the attacker is then able to craft input strings that subvert the intent of the query. Potentially, the attacker can gain unauthorized access to data, including security settings, and severely corrupt or destroy the database.\n\nThe principal protection against code injection is not to use dynamic execution except where it provides necessary functionality that cannot be utilized otherwise. Use strongly typed data items rather than general-purpose strings as input parameters to task-specific, pre-compiled stored procedures and functions (and triggers).\n\nWhen dynamic execution is necessary, ways to mitigate the risk include the following, which should be implemented both in the on-screen application and at the database level, in the stored procedures:\n-- Allow strings as input only when necessary. \n-- Rely on data typing to validate numbers, dates, etc. Do not accept invalid values. If substituting other values for them, think carefully about whether this could be subverted.\n-- Limit the size of input strings to what is truly necessary.\n-- If single quotes/apostrophes, double quotes, semicolons, equals signs, angle brackets, or square brackets will never be valid as input, reject them.\n-- If comment markers will never be valid as input, reject them. In SQL, these are -- or /* */ \n-- If HTML and XML tags, entities, comments, etc., will never be valid, reject them.\n-- If wildcards are present, reject them unless truly necessary. In SQL these are the underscore and the percentage sign, and the word ESCAPE is also a clue that wildcards are in use.\n-- If SQL key words, such as SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, DROP, ESCAPE, UNION, GRANT, REVOKE, DENY, MODIFY will never be valid, reject them. Use case-insensitive comparisons when searching for these. Bear in mind that some of these words, particularly Grant (as a person's name), could also be valid input. \n-- If there are range limits on the values that may be entered, enforce those limits.\n-- Institute procedures for inspection of programs for correct use of dynamic coding, by a party other than the developer.\n-- Conduct rigorous testing of program modules that use dynamic coding, searching for ways to subvert the intended use.\n-- Record the inspection and testing in the system documentation.\n-- Bear in mind that all this applies not only to screen input, but also to the values in an incoming message to a web service or to a stored procedure called by a software component that has not itself been hardened in these ways. Not only can the caller be subject to such vulnerabilities; it may itself be the attacker.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered\"\n  desc 'check', 'Review source code in the database (stored procedures, functions, triggers) and application source code to identify cases of dynamic code execution.\n\nIf dynamic code execution is employed without protective measures against code injection, this is a finding.'\n  desc 'fix', 'Where dynamic code execution is used, modify the code to implement protections against code injection.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67973r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67395'\n  tag rid: 'SV-81885r2_rule'\n  tag stig_id: 'SQL4-00-031600'\n  tag gtitle: 'SRG-APP-000251-DB-000392'\n  tag fix_id: 'F-73507r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001310']\n  tag nist: ['SI-10']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81885.rb"},"title":"The DBMS and associated applications, when making use of dynamic code execution, must scan input data for invalid values that may indicate a code injection attack.","desc":"With respect to database management systems, one class of threat is known as SQL Injection, or more generally, code injection. It takes advantage of the dynamic execution capabilities of various programming languages, including dialects of SQL. In such cases, the attacker deduces the manner in which SQL statements are being processed, either from inside knowledge or by observing system behavior in response to invalid inputs. When the attacker identifies scenarios where SQL queries are being assembled by application code (which may be within the database or separate from it) and executed dynamically, the attacker is then able to craft input strings that subvert the intent of the query. Potentially, the attacker can gain unauthorized access to data, including security settings, and severely corrupt or destroy the database.\n\nThe principal protection against code injection is not to use dynamic execution except where it provides necessary functionality that cannot be utilized otherwise. Use strongly typed data items rather than general-purpose strings as input parameters to task-specific, pre-compiled stored procedures and functions (and triggers).\n\nWhen dynamic execution is necessary, ways to mitigate the risk include the following, which should be implemented both in the on-screen application and at the database level, in the stored procedures:\n-- Allow strings as input only when necessary. \n-- Rely on data typing to validate numbers, dates, etc. Do not accept invalid values. If substituting other values for them, think carefully about whether this could be subverted.\n-- Limit the size of input strings to what is truly necessary.\n-- If single quotes/apostrophes, double quotes, semicolons, equals signs, angle brackets, or square brackets will never be valid as input, reject them.\n-- If comment markers will never be valid as input, reject them. In SQL, these are -- or /* */ \n-- If HTML and XML tags, entities, comments, etc., will never be valid, reject them.\n-- If wildcards are present, reject them unless truly necessary. In SQL these are the underscore and the percentage sign, and the word ESCAPE is also a clue that wildcards are in use.\n-- If SQL key words, such as SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, DROP, ESCAPE, UNION, GRANT, REVOKE, DENY, MODIFY will never be valid, reject them. Use case-insensitive comparisons when searching for these. Bear in mind that some of these words, particularly Grant (as a person's name), could also be valid input. \n-- If there are range limits on the values that may be entered, enforce those limits.\n-- Institute procedures for inspection of programs for correct use of dynamic coding, by a party other than the developer.\n-- Conduct rigorous testing of program modules that use dynamic coding, searching for ways to subvert the intended use.\n-- Record the inspection and testing in the system documentation.\n-- Bear in mind that all this applies not only to screen input, but also to the values in an incoming message to a web service or to a stored procedure called by a software component that has not itself been hardened in these ways. Not only can the caller be subject to such vulnerabilities; it may itself be the attacker.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered","descriptions":{"default":"With respect to database management systems, one class of threat is known as SQL Injection, or more generally, code injection. It takes advantage of the dynamic execution capabilities of various programming languages, including dialects of SQL. In such cases, the attacker deduces the manner in which SQL statements are being processed, either from inside knowledge or by observing system behavior in response to invalid inputs. When the attacker identifies scenarios where SQL queries are being assembled by application code (which may be within the database or separate from it) and executed dynamically, the attacker is then able to craft input strings that subvert the intent of the query. Potentially, the attacker can gain unauthorized access to data, including security settings, and severely corrupt or destroy the database.\n\nThe principal protection against code injection is not to use dynamic execution except where it provides necessary functionality that cannot be utilized otherwise. Use strongly typed data items rather than general-purpose strings as input parameters to task-specific, pre-compiled stored procedures and functions (and triggers).\n\nWhen dynamic execution is necessary, ways to mitigate the risk include the following, which should be implemented both in the on-screen application and at the database level, in the stored procedures:\n-- Allow strings as input only when necessary. \n-- Rely on data typing to validate numbers, dates, etc. Do not accept invalid values. If substituting other values for them, think carefully about whether this could be subverted.\n-- Limit the size of input strings to what is truly necessary.\n-- If single quotes/apostrophes, double quotes, semicolons, equals signs, angle brackets, or square brackets will never be valid as input, reject them.\n-- If comment markers will never be valid as input, reject them. In SQL, these are -- or /* */ \n-- If HTML and XML tags, entities, comments, etc., will never be valid, reject them.\n-- If wildcards are present, reject them unless truly necessary. In SQL these are the underscore and the percentage sign, and the word ESCAPE is also a clue that wildcards are in use.\n-- If SQL key words, such as SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, DROP, ESCAPE, UNION, GRANT, REVOKE, DENY, MODIFY will never be valid, reject them. Use case-insensitive comparisons when searching for these. Bear in mind that some of these words, particularly Grant (as a person's name), could also be valid input. \n-- If there are range limits on the values that may be entered, enforce those limits.\n-- Institute procedures for inspection of programs for correct use of dynamic coding, by a party other than the developer.\n-- Conduct rigorous testing of program modules that use dynamic coding, searching for ways to subvert the intended use.\n-- Record the inspection and testing in the system documentation.\n-- Bear in mind that all this applies not only to screen input, but also to the values in an incoming message to a web service or to a stored procedure called by a software component that has not itself been hardened in these ways. Not only can the caller be subject to such vulnerabilities; it may itself be the attacker.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered","check":"Review source code in the database (stored procedures, functions, triggers) and application source code to identify cases of dynamic code execution.\n\nIf dynamic code execution is employed without protective measures against code injection, this is a finding.","fix":"Where dynamic code execution is used, modify the code to implement protections against code injection."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67973r1_chk","severity":"medium","gid":"V-67395","rid":"SV-81885r2_rule","stig_id":"SQL4-00-031600","gtitle":"SRG-APP-000251-DB-000392","fix_id":"F-73507r1_fix","documentable":null,"cci":["CCI-001310"],"nist":["SI-10"]}},{"id":"SV-81887","code":"control 'SV-81887' do\n  title 'The DBMS and associated applications must provide non-privileged users with error messages that provide information necessary for corrective actions without revealing information that could be exploited by adversaries.'\n  desc %q(Any DBMS or associated application providing too much information in error messages on the screen or printout risks compromising the data and security of the system. The structure and content of error messages need to be carefully considered by the organization and development team.\n\nDatabases can inadvertently provide a wealth of information to an attacker through improperly handled error messages. In addition to sensitive business or personal information, database errors can provide host names, IP addresses, user names, and other system information not required for end-user troubleshooting but very useful to someone targeting the system.\n\nCarefully consider the structure/content of error messages. The extent to which information systems are able to identify and handle error conditions is guided by organizational policy and operational requirements. Information that could be exploited by adversaries includes, for example, logon attempts with passwords entered by mistake as the username, mission/business information that can be derived from (if not stated explicitly by) information recorded, and personal information, such as account numbers, social security numbers, and credit card numbers.\n\nIt is important that detailed error messages be visible only to those who are authorized to view them; that general users receive only generalized acknowledgment that errors have occurred; and that these generalized messages appear only when relevant to the user's task. For example, a message along the lines of, \"An error has occurred. Unable to save your changes. If this problem persists, please contact your help desk\" would be relevant. A message such as \"Warning: your transaction generated a large number of page splits\" would likely not be relevant. \"ABGQ is not a valid widget code\" would be appropriate; but \"The INSERT statement conflicted with the FOREIGN KEY constraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\", table \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too much about the database structure.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.)\n  desc 'check', 'Review application behavior and custom database code (stored procedures; triggers),  to determine whether  error messages contain information beyond what is needed for explaining the issue to general users.\n\nIf database error messages contain PII data, sensitive business data, or information useful for identifying the host system or database structure, this is a finding.'\n  desc 'fix', 'Configure DBMS settings, custom database code, and associated application code not to divulge sensitive information or information useful for system identification in error messages that are displayed to general users.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67975r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67397'\n  tag rid: 'SV-81887r2_rule'\n  tag stig_id: 'SQL4-00-022800'\n  tag gtitle: 'SRG-APP-000266-DB-000162'\n  tag fix_id: 'F-73509r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001312']\n  tag nist: ['SI-11 a']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81887.rb"},"title":"The DBMS and associated applications must provide non-privileged users with error messages that provide information necessary for corrective actions without revealing information that could be exploited by adversaries.","desc":"Any DBMS or associated application providing too much information in error messages on the screen or printout risks compromising the data and security of the system. The structure and content of error messages need to be carefully considered by the organization and development team.\n\nDatabases can inadvertently provide a wealth of information to an attacker through improperly handled error messages. In addition to sensitive business or personal information, database errors can provide host names, IP addresses, user names, and other system information not required for end-user troubleshooting but very useful to someone targeting the system.\n\nCarefully consider the structure/content of error messages. The extent to which information systems are able to identify and handle error conditions is guided by organizational policy and operational requirements. Information that could be exploited by adversaries includes, for example, logon attempts with passwords entered by mistake as the username, mission/business information that can be derived from (if not stated explicitly by) information recorded, and personal information, such as account numbers, social security numbers, and credit card numbers.\n\nIt is important that detailed error messages be visible only to those who are authorized to view them; that general users receive only generalized acknowledgment that errors have occurred; and that these generalized messages appear only when relevant to the user's task. For example, a message along the lines of, \"An error has occurred. Unable to save your changes. If this problem persists, please contact your help desk\" would be relevant. A message such as \"Warning: your transaction generated a large number of page splits\" would likely not be relevant. \"ABGQ is not a valid widget code\" would be appropriate; but \"The INSERT statement conflicted with the FOREIGN KEY constraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\", table \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too much about the database structure.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","descriptions":{"default":"Any DBMS or associated application providing too much information in error messages on the screen or printout risks compromising the data and security of the system. The structure and content of error messages need to be carefully considered by the organization and development team.\n\nDatabases can inadvertently provide a wealth of information to an attacker through improperly handled error messages. In addition to sensitive business or personal information, database errors can provide host names, IP addresses, user names, and other system information not required for end-user troubleshooting but very useful to someone targeting the system.\n\nCarefully consider the structure/content of error messages. The extent to which information systems are able to identify and handle error conditions is guided by organizational policy and operational requirements. Information that could be exploited by adversaries includes, for example, logon attempts with passwords entered by mistake as the username, mission/business information that can be derived from (if not stated explicitly by) information recorded, and personal information, such as account numbers, social security numbers, and credit card numbers.\n\nIt is important that detailed error messages be visible only to those who are authorized to view them; that general users receive only generalized acknowledgment that errors have occurred; and that these generalized messages appear only when relevant to the user's task. For example, a message along the lines of, \"An error has occurred. Unable to save your changes. If this problem persists, please contact your help desk\" would be relevant. A message such as \"Warning: your transaction generated a large number of page splits\" would likely not be relevant. \"ABGQ is not a valid widget code\" would be appropriate; but \"The INSERT statement conflicted with the FOREIGN KEY constraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\", table \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too much about the database structure.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","check":"Review application behavior and custom database code (stored procedures; triggers),  to determine whether  error messages contain information beyond what is needed for explaining the issue to general users.\n\nIf database error messages contain PII data, sensitive business data, or information useful for identifying the host system or database structure, this is a finding.","fix":"Configure DBMS settings, custom database code, and associated application code not to divulge sensitive information or information useful for system identification in error messages that are displayed to general users."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67975r1_chk","severity":"medium","gid":"V-67397","rid":"SV-81887r2_rule","stig_id":"SQL4-00-022800","gtitle":"SRG-APP-000266-DB-000162","fix_id":"F-73509r1_fix","documentable":null,"cci":["CCI-001312"],"nist":["SI-11 a"]}},{"id":"SV-81889","code":"control 'SV-81889' do\n  title 'SQL Server must reveal detailed error messages only to the ISSO, ISSM (or their designees), SA and DBA.'\n  desc %q(If the DBMS provides too much information in error logs and administrative messages to the screen, this could lead to compromise. The structure and content of error messages need to be carefully considered by the organization and development team. The extent to which the information system is able to identify and handle error conditions is guided by organizational policy and operational requirements. \n\nSome default DBMS error messages can contain information that could aid an attacker in, among others things, identifying the database type, host address, or state of the database. Custom errors may contain sensitive customer information. \n\nIt is important that detailed error messages be visible only to those who are authorized to view them; that general users receive only generalized acknowledgment that errors have occurred; and that these generalized messages appear only when relevant to the user's task. For example, a message along the lines of, \"An error has occurred. Unable to save your changes. If this problem persists, please contact your help desk\" would be relevant. A message such as \"Warning: your transaction generated a large number of page splits\" would likely not be relevant. \"ABGQ is not a valid widget code\" would be appropriate; but \"The INSERT statement conflicted with the FOREIGN KEY constraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\", table \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too much about the database structure.\n\nAdministrative users authorized to review detailed error messages typically are the ISSO, ISSM, SA and DBA. Other individuals or roles may be specified according to organization-specific needs, with appropriate approval.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.)\n  desc 'check', 'Review application behavior, custom database code (stored procedures; triggers) and DBMS audit and trace settings,  to determine whether detailed error messages are logged or stored for review by authorized personnel.\n\nIf detailed error messages are not available to individuals authorized to view them, this is a finding.'\n  desc 'fix', 'Configure audit logging, tracing and/or custom code in the database or application to record detailed error messages generated by SQL Server, for review by authorized personnel.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67977r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67399'\n  tag rid: 'SV-81889r2_rule'\n  tag stig_id: 'SQL4-00-022900'\n  tag gtitle: 'SRG-APP-000267-DB-000163'\n  tag fix_id: 'F-73511r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001314']\n  tag nist: ['SI-11 b']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81889.rb"},"title":"SQL Server must reveal detailed error messages only to the ISSO, ISSM (or their designees), SA and DBA.","desc":"If the DBMS provides too much information in error logs and administrative messages to the screen, this could lead to compromise. The structure and content of error messages need to be carefully considered by the organization and development team. The extent to which the information system is able to identify and handle error conditions is guided by organizational policy and operational requirements. \n\nSome default DBMS error messages can contain information that could aid an attacker in, among others things, identifying the database type, host address, or state of the database. Custom errors may contain sensitive customer information. \n\nIt is important that detailed error messages be visible only to those who are authorized to view them; that general users receive only generalized acknowledgment that errors have occurred; and that these generalized messages appear only when relevant to the user's task. For example, a message along the lines of, \"An error has occurred. Unable to save your changes. If this problem persists, please contact your help desk\" would be relevant. A message such as \"Warning: your transaction generated a large number of page splits\" would likely not be relevant. \"ABGQ is not a valid widget code\" would be appropriate; but \"The INSERT statement conflicted with the FOREIGN KEY constraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\", table \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too much about the database structure.\n\nAdministrative users authorized to review detailed error messages typically are the ISSO, ISSM, SA and DBA. Other individuals or roles may be specified according to organization-specific needs, with appropriate approval.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","descriptions":{"default":"If the DBMS provides too much information in error logs and administrative messages to the screen, this could lead to compromise. The structure and content of error messages need to be carefully considered by the organization and development team. The extent to which the information system is able to identify and handle error conditions is guided by organizational policy and operational requirements. \n\nSome default DBMS error messages can contain information that could aid an attacker in, among others things, identifying the database type, host address, or state of the database. Custom errors may contain sensitive customer information. \n\nIt is important that detailed error messages be visible only to those who are authorized to view them; that general users receive only generalized acknowledgment that errors have occurred; and that these generalized messages appear only when relevant to the user's task. For example, a message along the lines of, \"An error has occurred. Unable to save your changes. If this problem persists, please contact your help desk\" would be relevant. A message such as \"Warning: your transaction generated a large number of page splits\" would likely not be relevant. \"ABGQ is not a valid widget code\" would be appropriate; but \"The INSERT statement conflicted with the FOREIGN KEY constraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\", table \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too much about the database structure.\n\nAdministrative users authorized to review detailed error messages typically are the ISSO, ISSM, SA and DBA. Other individuals or roles may be specified according to organization-specific needs, with appropriate approval.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","check":"Review application behavior, custom database code (stored procedures; triggers) and DBMS audit and trace settings,  to determine whether detailed error messages are logged or stored for review by authorized personnel.\n\nIf detailed error messages are not available to individuals authorized to view them, this is a finding.","fix":"Configure audit logging, tracing and/or custom code in the database or application to record detailed error messages generated by SQL Server, for review by authorized personnel."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67977r1_chk","severity":"medium","gid":"V-67399","rid":"SV-81889r2_rule","stig_id":"SQL4-00-022900","gtitle":"SRG-APP-000267-DB-000163","fix_id":"F-73511r1_fix","documentable":null,"cci":["CCI-001314"],"nist":["SI-11 b"]}},{"id":"SV-81891","code":"control 'SV-81891' do\n  title 'When supporting applications that require security labeling of data, SQL Server must associate organization-defined types of security labels having organization-defined security label values with information in storage.'\n  desc 'Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.'\n  desc 'check', 'If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security labeling is not implemented or does not reliably maintain labels on information in storage, this is a finding.'\n  desc 'fix', 'Develop SQL or application code or acquire a third party tool to perform data labeling.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67979r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67401'\n  tag rid: 'SV-81891r2_rule'\n  tag stig_id: 'SQL4-00-031900'\n  tag gtitle: 'SRG-APP-000311-DB-000308'\n  tag fix_id: 'F-73513r2_fix'\n  tag 'documentable'\n  tag cci: ['CCI-002262']\n  tag nist: ['AC-16 a']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81891.rb"},"title":"When supporting applications that require security labeling of data, SQL Server must associate organization-defined types of security labels having organization-defined security label values with information in storage.","desc":"Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.","descriptions":{"default":"Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.","check":"If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security labeling is not implemented or does not reliably maintain labels on information in storage, this is a finding.","fix":"Develop SQL or application code or acquire a third party tool to perform data labeling."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67979r1_chk","severity":"medium","gid":"V-67401","rid":"SV-81891r2_rule","stig_id":"SQL4-00-031900","gtitle":"SRG-APP-000311-DB-000308","fix_id":"F-73513r2_fix","documentable":null,"cci":["CCI-002262"],"nist":["AC-16 a"]}},{"id":"SV-81893","code":"control 'SV-81893' do\n  title 'When supporting applications that require security labeling of data, SQL Server must associate organization-defined types of security labels having organization-defined security label values with information in process.'\n  desc 'Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.'\n  desc 'check', 'If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security labeling is not implemented or does not reliably maintain labels on information in process, this is a finding.'\n  desc 'fix', 'Develop SQL or application code or acquire a third party tool to perform data labeling.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67981r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67403'\n  tag rid: 'SV-81893r2_rule'\n  tag stig_id: 'SQL4-00-032000'\n  tag gtitle: 'SRG-APP-000313-DB-000309'\n  tag fix_id: 'F-73515r2_fix'\n  tag 'documentable'\n  tag cci: ['CCI-002263']\n  tag nist: ['AC-16 a']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81893.rb"},"title":"When supporting applications that require security labeling of data, SQL Server must associate organization-defined types of security labels having organization-defined security label values with information in process.","desc":"Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.","descriptions":{"default":"Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.","check":"If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security labeling is not implemented or does not reliably maintain labels on information in process, this is a finding.","fix":"Develop SQL or application code or acquire a third party tool to perform data labeling."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67981r1_chk","severity":"medium","gid":"V-67403","rid":"SV-81893r2_rule","stig_id":"SQL4-00-032000","gtitle":"SRG-APP-000313-DB-000309","fix_id":"F-73515r2_fix","documentable":null,"cci":["CCI-002263"],"nist":["AC-16 a"]}},{"id":"SV-81895","code":"control 'SV-81895' do\n  title 'When supporting applications that require security labeling of data, SQL Server must associate organization-defined types of security labels having organization-defined security label values with information in transmission.'\n  desc 'Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.'\n  desc 'check', 'If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security labeling is not implemented or does not reliably maintain labels on information in transmission, this is a finding.'\n  desc 'fix', 'Develop SQL or application code or acquire a third party tool to perform data labeling.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67983r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67405'\n  tag rid: 'SV-81895r2_rule'\n  tag stig_id: 'SQL4-00-032100'\n  tag gtitle: 'SRG-APP-000314-DB-000310'\n  tag fix_id: 'F-73517r3_fix'\n  tag 'documentable'\n  tag cci: ['CCI-002264']\n  tag nist: ['AC-16 a']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81895.rb"},"title":"When supporting applications that require security labeling of data, SQL Server must associate organization-defined types of security labels having organization-defined security label values with information in transmission.","desc":"Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.","descriptions":{"default":"Without the association of security labels to information, there is no basis for the DBMS to make security-related access-control decisions.\n\nSecurity labels are abstractions representing the basic properties or characteristics of an entity (e.g., subjects and objects) with respect to safeguarding information. \n\nThese labels are typically associated with internal data structures (e.g., tables, rows) within the database and are used to enable the implementation of access control and flow control policies, reflect special dissemination, handling or distribution instructions, or support other aspects of the information security policy. \n\nOne example includes marking data as classified or FOUO. These security labels may be assigned manually or during data processing, but, either way, it is imperative these assignments are maintained while the data is in storage. If the security labels are lost when the data is stored, there is the risk of a data compromise.\n\nSQL Server does not include security labeling as a standard or licensable feature. Earlier releases of this STIG suggested using the SQL Server Label Security Toolkit, from codeplex.com.  However, codeplex.com has been shut down, and it is unclear whether the Toolkit is still supported.  If the organization does have access to the Toolkit, it may still be used, provided the organization accepts responsibility for its support.  Other implementations may also exist. Custom application code is also a viable way to implement a solution.","check":"If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security labeling is not implemented or does not reliably maintain labels on information in transmission, this is a finding.","fix":"Develop SQL or application code or acquire a third party tool to perform data labeling."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67983r1_chk","severity":"medium","gid":"V-67405","rid":"SV-81895r2_rule","stig_id":"SQL4-00-032100","gtitle":"SRG-APP-000314-DB-000310","fix_id":"F-73517r3_fix","documentable":null,"cci":["CCI-002264"],"nist":["AC-16 a"]}},{"id":"SV-81897","code":"control 'SV-81897' do\n  title 'Time stamps in database tables, intended for auditing or activity-tracking purposes, must include both date and time of day, with a minimum granularity of one second.'\n  desc %q(If time stamps are not consistently applied and there is no common time reference, it is difficult to perform forensic analysis, in audit files, trace files/tables, and application data tables.\n\nTime stamps generated by SQL Server must include date and time, to a granularity of one second or finer. Time is commonly expressed in Coordinated Universal Time (UTC), a modern continuation of Greenwich Mean Time (GMT), or local time with an offset from UTC. Granularity of time measurements refers to the precision available in time stamp values. Granularity coarser than one second is not sufficient for audit trail purposes, and granularity finer than one second is recommended. Time stamp values are typically presented with three or more decimal places of seconds; however, the actual granularity may be coarser than the apparent precision. For example, SQL Server's GETDATE()/CURRENT_TMESTAMP values are presented to three decimal places, but the granularity is not one millisecond: it is about 1/300 of a second. \n\nThe data types that can be used for this purpose in SQL Server are:\nDATETIME2 - precision variable from a whole second down to a ten-millionth (subject to the actual precision of the hardware and operating system)\nDATETIMEOFFSET - as datetime2, together with local offset from UTC\nDATE, together with TIME (same precision considerations as for datetime2)\nDATETIME - precision 1/300 of a second\nCharacter-string data types allowing for at least 20 characters are also permissible, but not recommended.\n\nSQL Server built-in functions for retrieving current timestamps are:  (high precision) sysdatetime(), sysdatetimeoffset(), sysutcdatetime();  (lower precision) CURRENT_TIMESTAMP or getdate(), getutcdate().\n\nEnsure that values recorded for tracking purposes in data tables are correctly defined and maintained.  (Design decisions about which tables require audit-trail or activity-tracking columns are outside the scope of this STIG.  This requirement applies only to the data type and maintenance of such columns if they do exist.)\n\nThe SMALLDATETIME data type is not precise enough for this purpose.  Although it gives the impression of including a seconds component, the seconds value is always \"00\".\n\nSQL Server offers a data type called TIMESTAMP that is not a representation of date and time. Rather, it is a database state counter and does not correspond to calendar and clock time. This requirement does not refer to that meaning of TIMESTAMP.  To avoid confusion, Microsoft recommends using the newer name for this data type, ROWVERSION, instead.)\n  desc 'check', 'Review the column definitions and contents of audit-trail and activity-tracking timestamps in database tables.\n\nIf these are not defined and maintained to include date and time of day, accurate to a granularity of one second or finer, this is a finding.'\n  desc 'fix', 'Modify applications and/or column/field definitions so that the time stamps in audit-trail and activity-tracking columns/fields in application data include date and time of day, to a granularity of one second or finer, and are recorded accurately.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67985r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67407'\n  tag rid: 'SV-81897r1_rule'\n  tag stig_id: 'SQL4-00-033700'\n  tag gtitle: 'SRG-APP-000375-DB-000323'\n  tag fix_id: 'F-73519r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001889']\n  tag nist: ['AU-8 b']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81897.rb"},"title":"Time stamps in database tables, intended for auditing or activity-tracking purposes, must include both date and time of day, with a minimum granularity of one second.","desc":"If time stamps are not consistently applied and there is no common time reference, it is difficult to perform forensic analysis, in audit files, trace files/tables, and application data tables.\n\nTime stamps generated by SQL Server must include date and time, to a granularity of one second or finer. Time is commonly expressed in Coordinated Universal Time (UTC), a modern continuation of Greenwich Mean Time (GMT), or local time with an offset from UTC. Granularity of time measurements refers to the precision available in time stamp values. Granularity coarser than one second is not sufficient for audit trail purposes, and granularity finer than one second is recommended. Time stamp values are typically presented with three or more decimal places of seconds; however, the actual granularity may be coarser than the apparent precision. For example, SQL Server's GETDATE()/CURRENT_TMESTAMP values are presented to three decimal places, but the granularity is not one millisecond: it is about 1/300 of a second. \n\nThe data types that can be used for this purpose in SQL Server are:\nDATETIME2 - precision variable from a whole second down to a ten-millionth (subject to the actual precision of the hardware and operating system)\nDATETIMEOFFSET - as datetime2, together with local offset from UTC\nDATE, together with TIME (same precision considerations as for datetime2)\nDATETIME - precision 1/300 of a second\nCharacter-string data types allowing for at least 20 characters are also permissible, but not recommended.\n\nSQL Server built-in functions for retrieving current timestamps are:  (high precision) sysdatetime(), sysdatetimeoffset(), sysutcdatetime();  (lower precision) CURRENT_TIMESTAMP or getdate(), getutcdate().\n\nEnsure that values recorded for tracking purposes in data tables are correctly defined and maintained.  (Design decisions about which tables require audit-trail or activity-tracking columns are outside the scope of this STIG.  This requirement applies only to the data type and maintenance of such columns if they do exist.)\n\nThe SMALLDATETIME data type is not precise enough for this purpose.  Although it gives the impression of including a seconds component, the seconds value is always \"00\".\n\nSQL Server offers a data type called TIMESTAMP that is not a representation of date and time. Rather, it is a database state counter and does not correspond to calendar and clock time. This requirement does not refer to that meaning of TIMESTAMP.  To avoid confusion, Microsoft recommends using the newer name for this data type, ROWVERSION, instead.","descriptions":{"default":"If time stamps are not consistently applied and there is no common time reference, it is difficult to perform forensic analysis, in audit files, trace files/tables, and application data tables.\n\nTime stamps generated by SQL Server must include date and time, to a granularity of one second or finer. Time is commonly expressed in Coordinated Universal Time (UTC), a modern continuation of Greenwich Mean Time (GMT), or local time with an offset from UTC. Granularity of time measurements refers to the precision available in time stamp values. Granularity coarser than one second is not sufficient for audit trail purposes, and granularity finer than one second is recommended. Time stamp values are typically presented with three or more decimal places of seconds; however, the actual granularity may be coarser than the apparent precision. For example, SQL Server's GETDATE()/CURRENT_TMESTAMP values are presented to three decimal places, but the granularity is not one millisecond: it is about 1/300 of a second. \n\nThe data types that can be used for this purpose in SQL Server are:\nDATETIME2 - precision variable from a whole second down to a ten-millionth (subject to the actual precision of the hardware and operating system)\nDATETIMEOFFSET - as datetime2, together with local offset from UTC\nDATE, together with TIME (same precision considerations as for datetime2)\nDATETIME - precision 1/300 of a second\nCharacter-string data types allowing for at least 20 characters are also permissible, but not recommended.\n\nSQL Server built-in functions for retrieving current timestamps are:  (high precision) sysdatetime(), sysdatetimeoffset(), sysutcdatetime();  (lower precision) CURRENT_TIMESTAMP or getdate(), getutcdate().\n\nEnsure that values recorded for tracking purposes in data tables are correctly defined and maintained.  (Design decisions about which tables require audit-trail or activity-tracking columns are outside the scope of this STIG.  This requirement applies only to the data type and maintenance of such columns if they do exist.)\n\nThe SMALLDATETIME data type is not precise enough for this purpose.  Although it gives the impression of including a seconds component, the seconds value is always \"00\".\n\nSQL Server offers a data type called TIMESTAMP that is not a representation of date and time. Rather, it is a database state counter and does not correspond to calendar and clock time. This requirement does not refer to that meaning of TIMESTAMP.  To avoid confusion, Microsoft recommends using the newer name for this data type, ROWVERSION, instead.","check":"Review the column definitions and contents of audit-trail and activity-tracking timestamps in database tables.\n\nIf these are not defined and maintained to include date and time of day, accurate to a granularity of one second or finer, this is a finding.","fix":"Modify applications and/or column/field definitions so that the time stamps in audit-trail and activity-tracking columns/fields in application data include date and time of day, to a granularity of one second or finer, and are recorded accurately."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67985r1_chk","severity":"medium","gid":"V-67407","rid":"SV-81897r1_rule","stig_id":"SQL4-00-033700","gtitle":"SRG-APP-000375-DB-000323","fix_id":"F-73519r1_fix","documentable":null,"cci":["CCI-001889"],"nist":["AU-8 b"]}},{"id":"SV-81899","code":"control 'SV-81899' do\n  title 'SQL Server must implement and/or support cryptographic mechanisms to prevent unauthorized modification of organization-defined information at rest (to include, at a minimum, PII and classified information) on organization-defined information system components.'\n  desc 'Databases holding data requiring \"data at rest\" protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to the DBMS or implemented via additional software or operating system/file system settings, as appropriate to the situation.\n\nSelection of a cryptographic mechanism is based on the need to protect the integrity of organizational information. The strength of the mechanism is commensurate with the security category and/or classification of the information. Organizations have the flexibility to either encrypt all information on storage devices (i.e., full disk encryption) or encrypt specific data structures (e.g., files, records, or fields). \n\nThe decision whether and what to encrypt rests with the data owner and is also influenced by the physical measures taken to secure the equipment and media on which the information resides.'\n  desc 'check', 'Review the system documentation to determine whether the organization has defined the information at rest that is to be protected from modification, which must include, at a minimum, PII and classified information.\n\nIf no information is identified as requiring such protection, this is not a finding.\n\nReview the configuration of SQL Server, Windows, and additional software as relevant.\n\nIf full-disk encryption is required, and Windows or the storage system is not configured for this, this is a finding.\n\nIf database transparent data encryption (TDE) is called for, check whether it is enabled:\nIn SQL Server Management Studio, Object Explorer, expand the instance and right-click on the database name; select properties.  Select the Options page, State section, Encryption Enabled parameter.\n\nIf the value displayed is False, this is a finding.\n\nIf column encryption, done via SQL Server features, is required, review the definitions and contents of the relevant tables and columns.\n\nIf any of the information defined as requiring cryptographic protection is not encrypted in a manner that provides the required level of protection, this is a finding.'\n  desc 'fix', 'Where full-disk encryption is required, configure Windows and/or the storage system to provide this.\n\nWhere transparent data encryption (TDE) is required, deploy the necessary stack of certificates and keys, and set the Encryption Enabled to True.  For guidance from the Microsoft Developer Network on how to do this, perform a web search for \"SQL Server 2014 TDE\".\n\nWhere column encryption is required, deploy the necessary stack of certificates and keys, and enable encryption on the columns in question.  For guidance from the Microsoft Developer Network on how to do this, perform a web search for \"SQL Server 2014 Encrypt a Column of Data\".'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67987r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67409'\n  tag rid: 'SV-81899r1_rule'\n  tag stig_id: 'SQL4-00-034700'\n  tag gtitle: 'SRG-APP-000428-DB-000386'\n  tag fix_id: 'F-73521r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-002475']\n  tag nist: ['SC-28 (1)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81899.rb"},"title":"SQL Server must implement and/or support cryptographic mechanisms to prevent unauthorized modification of organization-defined information at rest (to include, at a minimum, PII and classified information) on organization-defined information system components.","desc":"Databases holding data requiring \"data at rest\" protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to the DBMS or implemented via additional software or operating system/file system settings, as appropriate to the situation.\n\nSelection of a cryptographic mechanism is based on the need to protect the integrity of organizational information. The strength of the mechanism is commensurate with the security category and/or classification of the information. Organizations have the flexibility to either encrypt all information on storage devices (i.e., full disk encryption) or encrypt specific data structures (e.g., files, records, or fields). \n\nThe decision whether and what to encrypt rests with the data owner and is also influenced by the physical measures taken to secure the equipment and media on which the information resides.","descriptions":{"default":"Databases holding data requiring \"data at rest\" protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to the DBMS or implemented via additional software or operating system/file system settings, as appropriate to the situation.\n\nSelection of a cryptographic mechanism is based on the need to protect the integrity of organizational information. The strength of the mechanism is commensurate with the security category and/or classification of the information. Organizations have the flexibility to either encrypt all information on storage devices (i.e., full disk encryption) or encrypt specific data structures (e.g., files, records, or fields). \n\nThe decision whether and what to encrypt rests with the data owner and is also influenced by the physical measures taken to secure the equipment and media on which the information resides.","check":"Review the system documentation to determine whether the organization has defined the information at rest that is to be protected from modification, which must include, at a minimum, PII and classified information.\n\nIf no information is identified as requiring such protection, this is not a finding.\n\nReview the configuration of SQL Server, Windows, and additional software as relevant.\n\nIf full-disk encryption is required, and Windows or the storage system is not configured for this, this is a finding.\n\nIf database transparent data encryption (TDE) is called for, check whether it is enabled:\nIn SQL Server Management Studio, Object Explorer, expand the instance and right-click on the database name; select properties.  Select the Options page, State section, Encryption Enabled parameter.\n\nIf the value displayed is False, this is a finding.\n\nIf column encryption, done via SQL Server features, is required, review the definitions and contents of the relevant tables and columns.\n\nIf any of the information defined as requiring cryptographic protection is not encrypted in a manner that provides the required level of protection, this is a finding.","fix":"Where full-disk encryption is required, configure Windows and/or the storage system to provide this.\n\nWhere transparent data encryption (TDE) is required, deploy the necessary stack of certificates and keys, and set the Encryption Enabled to True.  For guidance from the Microsoft Developer Network on how to do this, perform a web search for \"SQL Server 2014 TDE\".\n\nWhere column encryption is required, deploy the necessary stack of certificates and keys, and enable encryption on the columns in question.  For guidance from the Microsoft Developer Network on how to do this, perform a web search for \"SQL Server 2014 Encrypt a Column of Data\"."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67987r1_chk","severity":"medium","gid":"V-67409","rid":"SV-81899r1_rule","stig_id":"SQL4-00-034700","gtitle":"SRG-APP-000428-DB-000386","fix_id":"F-73521r1_fix","documentable":null,"cci":["CCI-002475"],"nist":["SC-28 (1)"]}},{"id":"SV-81901","code":"control 'SV-81901' do\n  title 'When invalid inputs are received, SQL Server must behave in a predictable and documented manner that reflects organizational and system objectives.'\n  desc 'A common vulnerability is unplanned behavior when invalid inputs are received. This requirement guards against adverse or unintended system behavior caused by invalid inputs, where information system responses to the invalid input may be disruptive or cause the system to fail into an unsafe state.\n\nThe behavior will be derived from the organizational and system requirements and includes, but is not limited to, notification of the appropriate personnel, creating an audit record, and rejecting invalid input.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.'\n  desc 'check', 'Review system documentation to determine how input errors are to be handled in general and if any special handling is defined for specific circumstances.\n\nReview the source code for database program objects (stored procedures, functions, triggers) and application source code to identify how the system responds to invalid input.\n\nIf it does not implement the documented behavior, this is a finding.'\n  desc 'fix', 'Revise and deploy the source code for database program objects (stored procedures, functions, triggers) and application source code, to implement the documented behavior.'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67991r1_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67411'\n  tag rid: 'SV-81901r2_rule'\n  tag stig_id: 'SQL4-00-035200'\n  tag gtitle: 'SRG-APP-000447-DB-000393'\n  tag fix_id: 'F-73525r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-002754']\n  tag nist: ['SI-10 (3)']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81901.rb"},"title":"When invalid inputs are received, SQL Server must behave in a predictable and documented manner that reflects organizational and system objectives.","desc":"A common vulnerability is unplanned behavior when invalid inputs are received. This requirement guards against adverse or unintended system behavior caused by invalid inputs, where information system responses to the invalid input may be disruptive or cause the system to fail into an unsafe state.\n\nThe behavior will be derived from the organizational and system requirements and includes, but is not limited to, notification of the appropriate personnel, creating an audit record, and rejecting invalid input.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","descriptions":{"default":"A common vulnerability is unplanned behavior when invalid inputs are received. This requirement guards against adverse or unintended system behavior caused by invalid inputs, where information system responses to the invalid input may be disruptive or cause the system to fail into an unsafe state.\n\nThe behavior will be derived from the organizational and system requirements and includes, but is not limited to, notification of the appropriate personnel, creating an audit record, and rejecting invalid input.\n\nThis calls for inspection of application source code, which will require collaboration with the application developers. It is recognized that in many cases, the database administrator (DBA) is organizationally separate from the application developers and may have limited, if any, access to source code. Nevertheless, protections of this type are so important to the secure operation of databases that they must not be ignored. At a minimum, the DBA must attempt to obtain assurances from the development organization that this issue has been addressed and must document what has been discovered.","check":"Review system documentation to determine how input errors are to be handled in general and if any special handling is defined for specific circumstances.\n\nReview the source code for database program objects (stored procedures, functions, triggers) and application source code to identify how the system responds to invalid input.\n\nIf it does not implement the documented behavior, this is a finding.","fix":"Revise and deploy the source code for database program objects (stored procedures, functions, triggers) and application source code, to implement the documented behavior."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67991r1_chk","severity":"medium","gid":"V-67411","rid":"SV-81901r2_rule","stig_id":"SQL4-00-035200","gtitle":"SRG-APP-000447-DB-000393","fix_id":"F-73525r1_fix","documentable":null,"cci":["CCI-002754"],"nist":["SI-10 (3)"]}},{"id":"SV-81903","code":"control 'SV-81903' do\n  title 'Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is accessed.'\n  desc 'Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.  Note also that Trace does not support auditing of SELECT statements, whereas Audit does.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide this tracking at the application level, if Trace is used for audit purposes.'\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s) using the database to verify that all SELECT actions on categorized data are being audited, and that the tracking records are written to the SQL Server Trace.  If not, this is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, implement tracking of SELECTs on categorized data at the application level, using the system stored procedure sp_trace_generateevent to write the tracking records to the Trace used for audit purposes.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67993r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67413'\n  tag rid: 'SV-81903r2_rule'\n  tag stig_id: 'SQL4-00-035800'\n  tag gtitle: 'SRG-APP-000494-DB-000344'\n  tag fix_id: 'F-73527r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81903.rb"},"title":"Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is accessed.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.  Note also that Trace does not support auditing of SELECT statements, whereas Audit does.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide this tracking at the application level, if Trace is used for audit purposes.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.  Note also that Trace does not support auditing of SELECT statements, whereas Audit does.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide this tracking at the application level, if Trace is used for audit purposes.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s) using the database to verify that all SELECT actions on categorized data are being audited, and that the tracking records are written to the SQL Server Trace.  If not, this is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, implement tracking of SELECTs on categorized data at the application level, using the system stored procedure sp_trace_generateevent to write the tracking records to the Trace used for audit purposes.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67993r3_chk","severity":"medium","gid":"V-67413","rid":"SV-81903r2_rule","stig_id":"SQL4-00-035800","gtitle":"SRG-APP-000494-DB-000344","fix_id":"F-73527r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81905","code":"control 'SV-81905' do\n  title 'Trace or Audit records must be generated  when unsuccessful attempts to access categorized information (e.g., classification levels/security levels) occur.'\n  desc \"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.  Note also that Trace does not support auditing of SELECT statements, whereas Audit does.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide this tracking at the application level, if Trace is used for audit purposes.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.\"\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s) using the database to verify that all SELECT actions on categorized data, including unsuccessful attempts, are being audited;  and that the tracking records are written to the SQL Server Trace used for audit purposes.  If not, this is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, implement tracking of SELECTs on categorized data at the application level, using the system stored procedure sp_trace_generateevent to write the tracking records to the Trace used for audit purposes. Include failed attempts in the tracking.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67995r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67415'\n  tag rid: 'SV-81905r2_rule'\n  tag stig_id: 'SQL4-00-035900'\n  tag gtitle: 'SRG-APP-000494-DB-000345'\n  tag fix_id: 'F-73529r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81905.rb"},"title":"Trace or Audit records must be generated  when unsuccessful attempts to access categorized information (e.g., classification levels/security levels) occur.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.  Note also that Trace does not support auditing of SELECT statements, whereas Audit does.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide this tracking at the application level, if Trace is used for audit purposes.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.  Note also that Trace does not support auditing of SELECT statements, whereas Audit does.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide this tracking at the application level, if Trace is used for audit purposes.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s) using the database to verify that all SELECT actions on categorized data, including unsuccessful attempts, are being audited;  and that the tracking records are written to the SQL Server Trace used for audit purposes.  If not, this is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, implement tracking of SELECTs on categorized data at the application level, using the system stored procedure sp_trace_generateevent to write the tracking records to the Trace used for audit purposes. Include failed attempts in the tracking.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67995r3_chk","severity":"medium","gid":"V-67415","rid":"SV-81905r2_rule","stig_id":"SQL4-00-035900","gtitle":"SRG-APP-000494-DB-000345","fix_id":"F-73529r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81907","code":"control 'SV-81907' do\n  title 'SQL Server must generate Trace or Audit records when privileges/permissions are modified via locally-defined security objects.'\n  desc 'Changes in the permissions, privileges, and roles granted to users and roles must be tracked. Without an audit trail, unauthorized elevation or restriction of privileges could go undetected. Elevated privileges give users access to information and functionality that they should not have; restricted privileges wrongly deny access to authorized users.\n\nIn SQL Server, there is no distinction between modification of permissions and granting or dropping them.  However, native SQL Server security functionality may be supplemented with application-specific tables and logic, in which case the following actions on these tables and procedures/triggers/functions are also relevant:\nUPDATE\nEXECUTE\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.'\n  desc 'check', %q(Obtain the list of locally-defined security tables, procedures and functions that require tracking.\n\nIf there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined security tables for the existence of triggers to raise a custom event on each Update operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event \n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related procedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.  \nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67997r2_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67417'\n  tag rid: 'SV-81907r2_rule'\n  tag stig_id: 'SQL4-00-036200'\n  tag gtitle: 'SRG-APP-000495-DB-000328'\n  tag fix_id: 'F-73531r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81907.rb"},"title":"SQL Server must generate Trace or Audit records when privileges/permissions are modified via locally-defined security objects.","desc":"Changes in the permissions, privileges, and roles granted to users and roles must be tracked. Without an audit trail, unauthorized elevation or restriction of privileges could go undetected. Elevated privileges give users access to information and functionality that they should not have; restricted privileges wrongly deny access to authorized users.\n\nIn SQL Server, there is no distinction between modification of permissions and granting or dropping them.  However, native SQL Server security functionality may be supplemented with application-specific tables and logic, in which case the following actions on these tables and procedures/triggers/functions are also relevant:\nUPDATE\nEXECUTE\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","descriptions":{"default":"Changes in the permissions, privileges, and roles granted to users and roles must be tracked. Without an audit trail, unauthorized elevation or restriction of privileges could go undetected. Elevated privileges give users access to information and functionality that they should not have; restricted privileges wrongly deny access to authorized users.\n\nIn SQL Server, there is no distinction between modification of permissions and granting or dropping them.  However, native SQL Server security functionality may be supplemented with application-specific tables and logic, in which case the following actions on these tables and procedures/triggers/functions are also relevant:\nUPDATE\nEXECUTE\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","check":"Obtain the list of locally-defined security tables, procedures and functions that require tracking.\n\nIf there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined security tables for the existence of triggers to raise a custom event on each Update operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event \n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related procedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.  \nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67997r2_chk","severity":"medium","gid":"V-67417","rid":"SV-81907r2_rule","stig_id":"SQL4-00-036200","gtitle":"SRG-APP-000495-DB-000328","fix_id":"F-73531r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81909","code":"control 'SV-81909' do\n  title 'SQL Server must generate Trace or Audit records when unsuccessful attempts to modify privileges/permissions via locally-defined security objects occur.'\n  desc \"Failed attempts to change the permissions, privileges, and roles granted to users and roles must be tracked. Without an audit trail, unauthorized attempts to elevate or restrict privileges could go undetected. \n\nIn SQL Server, there is no distinction between modification of permissions and granting or dropping them.  However, native SQL Server security functionality may be supplemented with application-specific tables and logic, in which case the following actions on these tables and procedures/triggers/functions are also relevant:\nUPDATE\nEXECUTE\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to the system views (and all other schema-scoped objects).  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.\"\n  desc 'check', %q(Obtain the list of locally-defined security tables, procedures and functions that require tracking.  If there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined security tables for the existence of triggers to raise a custom event on each Update operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event \n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related procedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-67999r4_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67419'\n  tag rid: 'SV-81909r2_rule'\n  tag stig_id: 'SQL4-00-036300'\n  tag gtitle: 'SRG-APP-000495-DB-000329'\n  tag fix_id: 'F-73533r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81909.rb"},"title":"SQL Server must generate Trace or Audit records when unsuccessful attempts to modify privileges/permissions via locally-defined security objects occur.","desc":"Failed attempts to change the permissions, privileges, and roles granted to users and roles must be tracked. Without an audit trail, unauthorized attempts to elevate or restrict privileges could go undetected. \n\nIn SQL Server, there is no distinction between modification of permissions and granting or dropping them.  However, native SQL Server security functionality may be supplemented with application-specific tables and logic, in which case the following actions on these tables and procedures/triggers/functions are also relevant:\nUPDATE\nEXECUTE\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to the system views (and all other schema-scoped objects).  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","descriptions":{"default":"Failed attempts to change the permissions, privileges, and roles granted to users and roles must be tracked. Without an audit trail, unauthorized attempts to elevate or restrict privileges could go undetected. \n\nIn SQL Server, there is no distinction between modification of permissions and granting or dropping them.  However, native SQL Server security functionality may be supplemented with application-specific tables and logic, in which case the following actions on these tables and procedures/triggers/functions are also relevant:\nUPDATE\nEXECUTE\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to the system views (and all other schema-scoped objects).  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","check":"Obtain the list of locally-defined security tables, procedures and functions that require tracking.  If there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined security tables for the existence of triggers to raise a custom event on each Update operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event \n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related procedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-67999r4_chk","severity":"medium","gid":"V-67419","rid":"SV-81909r2_rule","stig_id":"SQL4-00-036300","gtitle":"SRG-APP-000495-DB-000329","fix_id":"F-73533r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81911","code":"control 'SV-81911' do\n  title 'SQL Server must generate Trace or Audit records when locally-defined security objects are modified.'\n  desc 'SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  ALTER operations on these objects must be monitored.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.'\n  desc 'check', %q(If there are no locally-defined security tables or procedures, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68001r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67421'\n  tag rid: 'SV-81911r2_rule'\n  tag stig_id: 'SQL4-00-036400'\n  tag gtitle: 'SRG-APP-000496-DB-000334'\n  tag fix_id: 'F-73535r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81911.rb"},"title":"SQL Server must generate Trace or Audit records when locally-defined security objects are modified.","desc":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  ALTER operations on these objects must be monitored.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","descriptions":{"default":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  ALTER operations on these objects must be monitored.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","check":"If there are no locally-defined security tables or procedures, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68001r3_chk","severity":"medium","gid":"V-67421","rid":"SV-81911r2_rule","stig_id":"SQL4-00-036400","gtitle":"SRG-APP-000496-DB-000334","fix_id":"F-73535r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81913","code":"control 'SV-81913' do\n  title 'SQL Server must generate Trace or Audit records when unsuccessful accesses to designated objects occur.'\n  desc 'Without tracking all or selected types of access to all or selected objects (tables, views, procedures, functions, etc.), it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one. \n\nTypes of access include, but are not necessarily limited to:\nSELECT\nINSERT\nUPDATE\nDELETE\nEXECUTE\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.'\n  desc 'check', %q(If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of SELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are none, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event ID should be among those listed; if not, this is a finding:\n\n162 -- User error message\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, define and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68003r5_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67423'\n  tag rid: 'SV-81913r3_rule'\n  tag stig_id: 'SQL4-00-038200'\n  tag gtitle: 'SRG-APP-000507-DB-000357'\n  tag fix_id: 'F-73537r3_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81913.rb"},"title":"SQL Server must generate Trace or Audit records when unsuccessful accesses to designated objects occur.","desc":"Without tracking all or selected types of access to all or selected objects (tables, views, procedures, functions, etc.), it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one. \n\nTypes of access include, but are not necessarily limited to:\nSELECT\nINSERT\nUPDATE\nDELETE\nEXECUTE\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","descriptions":{"default":"Without tracking all or selected types of access to all or selected objects (tables, views, procedures, functions, etc.), it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one. \n\nTypes of access include, but are not necessarily limited to:\nSELECT\nINSERT\nUPDATE\nDELETE\nEXECUTE\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","check":"If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of SELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are none, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event ID should be among those listed; if not, this is a finding:\n\n162 -- User error message\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, define and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68003r5_chk","severity":"medium","gid":"V-67423","rid":"SV-81913r3_rule","stig_id":"SQL4-00-038200","gtitle":"SRG-APP-000507-DB-000357","fix_id":"F-73537r3_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81915","code":"control 'SV-81915' do\n  title 'SQL Server must generate Trace or Audit records when successful accesses to designated objects occur.'\n  desc 'Without tracking all or selected types of access to all or selected objects (tables, views, procedures, functions, etc.), it would be difficult to establish, correlate, and investigate the events relating to an incident, or identify those responsible for one. \n\nTypes of access include, but are not necessarily limited to:\nSELECT\nINSERT\nUPDATE\nDELETE\nEXECUTE\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nTrace does not offer tracking of SELECT operations, so where this is required it must be implemented at the application level.'\n  desc 'check', %q(If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of SELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are none, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s) using the database to verify that all SELECT actions on categorized data are being audited, and that the tracking records are written to the SQL Server Trace used for audit purposes.  If not, this is a finding.\n\nReview the designated tables for the existence of triggers to raise a custom event on each Insert-Update-Delete operation.\n\nIf such triggers are not present, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event (at least one of these; 90 is used in the supplied script)\n162 -- User error message\n\nIf SQL Server Audit is in use, verify that execution of all SELECT, INSERT, UPDATE, DELETE, or EXECUTE actions on the designated objects, is audited,.\n\nIf any such actions are not audited, this is a finding.\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, implement tracking of SELECTs on designated tables at the application level, using the system stored procedure sp_trace_generateevent to write the tracking records to the Trace used for audit purposes.\n\nCreate triggers to raise a custom event on each table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nEnsure that Trace.sql includes blocks of code for event classes 42, 43, and 162.\n\nExecute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68005r5_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67425'\n  tag rid: 'SV-81915r3_rule'\n  tag stig_id: 'SQL4-00-038100'\n  tag gtitle: 'SRG-APP-000507-DB-000356'\n  tag fix_id: 'F-73539r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81915.rb"},"title":"SQL Server must generate Trace or Audit records when successful accesses to designated objects occur.","desc":"Without tracking all or selected types of access to all or selected objects (tables, views, procedures, functions, etc.), it would be difficult to establish, correlate, and investigate the events relating to an incident, or identify those responsible for one. \n\nTypes of access include, but are not necessarily limited to:\nSELECT\nINSERT\nUPDATE\nDELETE\nEXECUTE\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nTrace does not offer tracking of SELECT operations, so where this is required it must be implemented at the application level.","descriptions":{"default":"Without tracking all or selected types of access to all or selected objects (tables, views, procedures, functions, etc.), it would be difficult to establish, correlate, and investigate the events relating to an incident, or identify those responsible for one. \n\nTypes of access include, but are not necessarily limited to:\nSELECT\nINSERT\nUPDATE\nDELETE\nEXECUTE\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nTrace does not offer tracking of SELECT operations, so where this is required it must be implemented at the application level.","check":"If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of SELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are none, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s) using the database to verify that all SELECT actions on categorized data are being audited, and that the tracking records are written to the SQL Server Trace used for audit purposes.  If not, this is a finding.\n\nReview the designated tables for the existence of triggers to raise a custom event on each Insert-Update-Delete operation.\n\nIf such triggers are not present, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event (at least one of these; 90 is used in the supplied script)\n162 -- User error message\n\nIf SQL Server Audit is in use, verify that execution of all SELECT, INSERT, UPDATE, DELETE, or EXECUTE actions on the designated objects, is audited,.\n\nIf any such actions are not audited, this is a finding.\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, implement tracking of SELECTs on designated tables at the application level, using the system stored procedure sp_trace_generateevent to write the tracking records to the Trace used for audit purposes.\n\nCreate triggers to raise a custom event on each table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nEnsure that Trace.sql includes blocks of code for event classes 42, 43, and 162.\n\nExecute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68005r5_chk","severity":"medium","gid":"V-67425","rid":"SV-81915r3_rule","stig_id":"SQL4-00-038100","gtitle":"SRG-APP-000507-DB-000356","fix_id":"F-73539r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81917","code":"control 'SV-81917' do\n  title 'Trace or Audit records must be generated when unsuccessful attempts to delete categorized information (e.g., classification levels/security levels) occur.'\n  desc \"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit DELETE actions at the application level.  However, to capture all DELETEs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.\"\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all DELETE actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, create triggers to raise a custom event for DELETEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68007r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67427'\n  tag rid: 'SV-81917r2_rule'\n  tag stig_id: 'SQL4-00-037400'\n  tag gtitle: 'SRG-APP-000502-DB-000349'\n  tag fix_id: 'F-73541r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81917.rb"},"title":"Trace or Audit records must be generated when unsuccessful attempts to delete categorized information (e.g., classification levels/security levels) occur.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit DELETE actions at the application level.  However, to capture all DELETEs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit DELETE actions at the application level.  However, to capture all DELETEs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all DELETE actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, create triggers to raise a custom event for DELETEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68007r3_chk","severity":"medium","gid":"V-67427","rid":"SV-81917r2_rule","stig_id":"SQL4-00-037400","gtitle":"SRG-APP-000502-DB-000349","fix_id":"F-73541r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81919","code":"control 'SV-81919' do\n  title 'Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is deleted.'\n  desc 'Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit DELETE actions at the application level.  However, to capture all DELETEs, whether they come from the application or bypass it, the Trace must be configured to cover them.'\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all tables holding categorized information, to determine whether trace events are generated for all DELETE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\n\nIn the following, replace # with a trace ID being used for the auditing requirements.\n\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose. SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, create triggers to raise a custom event for DELETEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68009r4_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67429'\n  tag rid: 'SV-81919r2_rule'\n  tag stig_id: 'SQL4-00-037300'\n  tag gtitle: 'SRG-APP-000502-DB-000348'\n  tag fix_id: 'F-73543r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81919.rb"},"title":"Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is deleted.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit DELETE actions at the application level.  However, to capture all DELETEs, whether they come from the application or bypass it, the Trace must be configured to cover them.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit DELETE actions at the application level.  However, to capture all DELETEs, whether they come from the application or bypass it, the Trace must be configured to cover them.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all tables holding categorized information, to determine whether trace events are generated for all DELETE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\n\nIn the following, replace # with a trace ID being used for the auditing requirements.\n\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose. SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, create triggers to raise a custom event for DELETEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68009r4_chk","severity":"medium","gid":"V-67429","rid":"SV-81919r2_rule","stig_id":"SQL4-00-037300","gtitle":"SRG-APP-000502-DB-000348","fix_id":"F-73543r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81921","code":"control 'SV-81921' do\n  title 'SQL Server must generate Trace or Audit records when  unsuccessful attempts to drop locally-defined security objects occur.'\n  desc \"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  DROP operations on these objects must be monitored.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all attempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.\"\n  desc 'check', %q(If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68011r4_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67431'\n  tag rid: 'SV-81921r3_rule'\n  tag stig_id: 'SQL4-00-037200'\n  tag gtitle: 'SRG-APP-000501-DB-000337'\n  tag fix_id: 'F-73545r2_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81921.rb"},"title":"SQL Server must generate Trace or Audit records when  unsuccessful attempts to drop locally-defined security objects occur.","desc":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  DROP operations on these objects must be monitored.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all attempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.","descriptions":{"default":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  DROP operations on these objects must be monitored.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all attempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.","check":"If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68011r4_chk","severity":"medium","gid":"V-67431","rid":"SV-81921r3_rule","stig_id":"SQL4-00-037200","gtitle":"SRG-APP-000501-DB-000337","fix_id":"F-73545r2_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81923","code":"control 'SV-81923' do\n  title 'SQL Server must generate Trace or Audit records when locally-defined security objects are dropped.'\n  desc 'SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  DROP operations on these objects must be monitored.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.'\n  desc 'check', %q(If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed.\n\nIf no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68013r4_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67433'\n  tag rid: 'SV-81923r3_rule'\n  tag stig_id: 'SQL4-00-037100'\n  tag gtitle: 'SRG-APP-000501-DB-000336'\n  tag fix_id: 'F-73547r2_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81923.rb"},"title":"SQL Server must generate Trace or Audit records when locally-defined security objects are dropped.","desc":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  DROP operations on these objects must be monitored.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","descriptions":{"default":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  DROP operations on these objects must be monitored.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.","check":"If neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed.\n\nIf no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  \n\nCreate triggers to raise a custom event on each locally-defined security table that requires tracking of Insert-Update-Delete operations.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these.  \n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68013r4_chk","severity":"medium","gid":"V-67433","rid":"SV-81923r3_rule","stig_id":"SQL4-00-037100","gtitle":"SRG-APP-000501-DB-000336","fix_id":"F-73547r2_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81925","code":"control 'SV-81925' do\n  title 'SQL Server must generate Trace or Audit records when unsuccessful attempts to modify locally-defined security objects occur.'\n  desc \"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  ALTER operations on these objects must be monitored.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all attempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.\"\n  desc 'check', %q(If there are no locally-defined security tables or procedures, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68015r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67435'\n  tag rid: 'SV-81925r2_rule'\n  tag stig_id: 'SQL4-00-036500'\n  tag gtitle: 'SRG-APP-000496-DB-000335'\n  tag fix_id: 'F-73549r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81925.rb"},"title":"SQL Server must generate Trace or Audit records when unsuccessful attempts to modify locally-defined security objects occur.","desc":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  ALTER operations on these objects must be monitored.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all attempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.","descriptions":{"default":"SQL Server protects its built-in security objects (tables, views, functions, procedures, etc.) from alteration by database users and administrators.  However, applications sometimes have additional, security-related objects defined in the database.  ALTER operations on these objects must be monitored.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all attempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.","check":"If there are no locally-defined security tables or procedures, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this is a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any locally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, define  and enable a trace that captures all auditable events.  The script provided in the supplemental file Trace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that captures all auditable events.  The script provided in the supplemental file Audit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68015r3_chk","severity":"medium","gid":"V-67435","rid":"SV-81925r2_rule","stig_id":"SQL4-00-036500","gtitle":"SRG-APP-000496-DB-000335","fix_id":"F-73549r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81927","code":"control 'SV-81927' do\n  title 'Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is created.'\n  desc 'Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit INSERT actions at the application level.  However, to capture all INSERTs, whether they come from the application or bypass it, the Trace must be configured to cover them.'\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all INSERT actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, create triggers to raise a custom event for INSERTs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68017r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67437'\n  tag rid: 'SV-81927r2_rule'\n  tag stig_id: 'SQL4-00-036600'\n  tag gtitle: 'SRG-APP-000498-DB-000346'\n  tag fix_id: 'F-73551r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81927.rb"},"title":"Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is created.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit INSERT actions at the application level.  However, to capture all INSERTs, whether they come from the application or bypass it, the Trace must be configured to cover them.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit INSERT actions at the application level.  However, to capture all INSERTs, whether they come from the application or bypass it, the Trace must be configured to cover them.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all INSERT actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, create triggers to raise a custom event for INSERTs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68017r3_chk","severity":"medium","gid":"V-67437","rid":"SV-81927r2_rule","stig_id":"SQL4-00-036600","gtitle":"SRG-APP-000498-DB-000346","fix_id":"F-73551r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81929","code":"control 'SV-81929' do\n  title 'Trace or Audit records must be generated when unsuccessful attempts to create categorized information (e.g., classification levels/security levels) occur.'\n  desc \"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit INSERT actions at the application level.  However, to capture all INSERTs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False; and some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.\"\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all INSERT actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, create triggers to raise a custom event for INSERTs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68019r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67439'\n  tag rid: 'SV-81929r2_rule'\n  tag stig_id: 'SQL4-00-036800'\n  tag gtitle: 'SRG-APP-000498-DB-000347'\n  tag fix_id: 'F-73553r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81929.rb"},"title":"Trace or Audit records must be generated when unsuccessful attempts to create categorized information (e.g., classification levels/security levels) occur.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit INSERT actions at the application level.  However, to capture all INSERTs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False; and some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nTo aid in diagnosis, it is necessary to keep track of failed attempts in addition to the successful ones.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit INSERT actions at the application level.  However, to capture all INSERTs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False; and some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all INSERT actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, create triggers to raise a custom event for INSERTs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68019r3_chk","severity":"medium","gid":"V-67439","rid":"SV-81929r2_rule","stig_id":"SQL4-00-036800","gtitle":"SRG-APP-000498-DB-000347","fix_id":"F-73553r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81931","code":"control 'SV-81931' do\n  title 'Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is modified.'\n  desc 'Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit UPDATE actions at the application level.  However, to capture all UPDATEs, whether they come from the application or bypass it, the Trace must be configured to cover them.'\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all tables holding categorized information, to determine whether trace events are generated for all UPDATE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, create triggers to raise a custom event for UPDATEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68021r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67441'\n  tag rid: 'SV-81931r2_rule'\n  tag stig_id: 'SQL4-00-036650'\n  tag gtitle: 'SRG-APP-000498-DB-000346'\n  tag fix_id: 'F-73555r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81931.rb"},"title":"Trace or Audit records must be generated when categorized information (e.g., classification levels/security levels) is modified.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit UPDATE actions at the application level.  However, to capture all UPDATEs, whether they come from the application or bypass it, the Trace must be configured to cover them.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit UPDATE actions at the application level.  However, to capture all UPDATEs, whether they come from the application or bypass it, the Trace must be configured to cover them.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all tables holding categorized information, to determine whether trace events are generated for all UPDATE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, create triggers to raise a custom event for UPDATEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68021r3_chk","severity":"medium","gid":"V-67441","rid":"SV-81931r2_rule","stig_id":"SQL4-00-036650","gtitle":"SRG-APP-000498-DB-000346","fix_id":"F-73555r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-81933","code":"control 'SV-81933' do\n  title 'Trace or Audit records must be generated when unsuccessful attempts to modify categorized information (e.g., classification levels/security levels) occur.'\n  desc \"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit UPDATE actions at the application level.  However, to capture all UPDATEs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.\"\n  desc 'check', %q(Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all UPDATE actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.)\n  desc 'fix', 'Where SQL Server Trace is in use, create triggers to raise a custom event for UPDATEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68023r2_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67443'\n  tag rid: 'SV-81933r2_rule'\n  tag stig_id: 'SQL4-00-036850'\n  tag gtitle: 'SRG-APP-000498-DB-000347'\n  tag fix_id: 'F-73557r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-000172']\n  tag nist: ['AU-12 c']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-81933.rb"},"title":"Trace or Audit records must be generated when unsuccessful attempts to modify categorized information (e.g., classification levels/security levels) occur.","desc":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit UPDATE actions at the application level.  However, to capture all UPDATEs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","descriptions":{"default":"Changes in categorized information must be tracked. Without an audit trail, unauthorized access to protected data could go undetected.\n\nFor detailed information on categorizing information, refer to FIPS Publication 199, Standards for Security Categorization of Federal Information and Information Systems, and FIPS Publication 200, Minimum Security Requirements for Federal Information and Information Systems.\n\nUse of SQL Server Audit is recommended.  All features of SQL Server Audit are available in the Enterprise and Developer editions of SQL Server 2014.  It is not available at the database level in other editions.  For this or legacy reasons, the instance may be using SQL Server Trace for auditing, which remains an acceptable solution for the time being.  Note, however, that Microsoft intends to remove most aspects of Trace at some point after SQL Server 2016.\n\nSince Trace does not provide for tracking SELECT statements, it is necessary to provide that part of the tracking at the application level.  Because of this, it may also be appropriate to audit UPDATE actions at the application level.  However, to capture all UPDATEs, whether they come from the application or bypass it, the Trace must be configured to cover them.\n\nUse of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all accesses, successful and otherwise, to all schema-scoped objects.  The [Succeeded] column in the audit output indicates the success or failure of the attempted action.  Be aware, however, that it may report True in some cases where one would intuitively expect False.  For example, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has permission to perform that action, even though it contains an invalid expression.  Some other actions that one would consider failures (such as selecting from a table that does not exist) may not appear at all.","check":"Review the system documentation to determine whether it is required to track categories of information, such as classification or sensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes, this is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings, and the triggers on the tables holding categorized information, to determine whether all UPDATE actions on these tables are traced, including failed attempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing requirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is a finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90 is used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file Audit.sql uses the broad, server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility makes other techniques possible.  If an alternative technique is in use and demonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\nTo look at audits and audit specifications, in Management Studio's object explorer, expand \n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso, \n<server name> >> Databases >> <database name> >> Security >> Database Audit Specifications.\nAlternatively, review the contents of the system views with \"audit\" in their names.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions on tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE server_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_specifications WHERE [name] = '<server_audit_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\", this is a finding.","fix":"Where SQL Server Trace is in use, create triggers to raise a custom event for UPDATEs on each table holding categorized information.  The examples provided in the supplemental file CustomTraceEvents.sql can serve as the basis for these. \n\nAdd a block of code to the supplemental file Trace.sql for each custom event class (integers in the range 82-91; the same event class may be used for all such triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all auditable events and data items.  The script provided in the supplemental file Audit.sql can be used as the basis for this.  Supplement the standard audit data as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit specification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> ADD (SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_specification_name> WITH (STATE = ON);\nGO"},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68023r2_chk","severity":"medium","gid":"V-67443","rid":"SV-81933r2_rule","stig_id":"SQL4-00-036850","gtitle":"SRG-APP-000498-DB-000347","fix_id":"F-73557r1_fix","documentable":null,"cci":["CCI-000172"],"nist":["AU-12 c"]}},{"id":"SV-82367","code":"control 'SV-82367' do\n  title 'SQL Server must protect data at rest and ensure confidentiality and integrity of data.'\n  desc 'This control is intended to address the confidentiality and integrity of information at rest in non-mobile devices and covers user information and system information.  Information at rest refers to the state of information when it is located on a secondary storage device (e.g., disk drive, tape drive) within an organizational information system. Applications and application users generate information throughout the course of their application use.\n\nUser-generated data, as well as, application-specific configuration data, needs to be protected. Configurations and/or rule sets for firewalls, gateways, intrusion detection/prevention systems, filtering routers, and authenticator content are examples of system information likely requiring protection. Organizations may choose to employ different mechanisms to achieve confidentiality and integrity protections, as appropriate.\n\nIf the confidentiality and integrity of SQL Server data is not protected, the data will be open to compromise and unauthorized modification.\n\nProtective measures include encryption, physical security of the facility where the storage devices reside, operating system file permissions, and organizational controls.  Each of these should be applied as necessary and appropriate.'\n  desc 'check', \"If the application owner and Authorizing Official have determined that encryption of data at rest is NOT required, this is not a finding.\n\nIf the application owner and Authorizing Official have determined that encryption of data at rest is required, ensure the data on secondary devices is encrypted.\n\nIf full-disk encryption is being used, this is not a finding.\n\nIf DBMS data encryption is required, ensure the data is encrypted before being put on the secondary device by executing:\n\nSELECT\n      d.name AS [Database Name],\n      CASE e.encryption_state\n            WHEN 0 THEN 'No database encryption key present, no encryption'\n            WHEN 1 THEN 'Unencrypted'\n            WHEN 2 THEN 'Encryption in progress'\n            WHEN 3 THEN 'Encrypted'\n            WHEN 4 THEN 'Key change in progress'\n            WHEN 5 THEN 'Decryption in progress'\n            WHEN 6 THEN 'Protection change in progress'\n      END AS [Encryption State]\nFROM sys.dm_database_encryption_keys e\nRIGHT JOIN sys.databases d ON DB_NAME(e.database_id) = d.name\nWHERE d.name NOT IN ('master','model','msdb')\nORDER BY 1\n;\n\nFor each user database where encryption is required, verify that encryption is in effect. If not, this is a finding.\n\nVerify that there are physical security measures, operating system access control lists and organizational controls appropriate to the sensitivity level of the data in the database(s). If not, this is a finding.\"\n  desc 'fix', 'Apply appropriate controls to protect the confidentiality and integrity of data on a secondary device.\n\nWhere encryption is required, this can be done by full-disk encryption or by database encryption. To enable database encryption, create a master key, create a database encryption key, and protect it by using mechanisms tied to the master key, and then set encryption on.\n\nImplement physical security measures, operating system access control lists and organizational controls appropriate to the sensitivity level of the data in the database(s).'\n  impact 0.5\n  ref 'DPMS Target SQL Server Database 2014'\n  tag check_id: 'C-68445r3_chk'\n  tag severity: 'medium'\n  tag gid: 'V-67877'\n  tag rid: 'SV-82367r3_rule'\n  tag stig_id: 'SQL4-00-021300'\n  tag gtitle: 'SRG-APP-000231-DB-000154'\n  tag fix_id: 'F-73993r1_fix'\n  tag 'documentable'\n  tag cci: ['CCI-001199']\n  tag nist: ['SC-28']\nend","source_location":{"line":1,"ref":"U_MS_SQL_Server_2014_Database_STIG_V1R6/controls/SV-82367.rb"},"title":"SQL Server must protect data at rest and ensure confidentiality and integrity of data.","desc":"This control is intended to address the confidentiality and integrity of information at rest in non-mobile devices and covers user information and system information.  Information at rest refers to the state of information when it is located on a secondary storage device (e.g., disk drive, tape drive) within an organizational information system. Applications and application users generate information throughout the course of their application use.\n\nUser-generated data, as well as, application-specific configuration data, needs to be protected. Configurations and/or rule sets for firewalls, gateways, intrusion detection/prevention systems, filtering routers, and authenticator content are examples of system information likely requiring protection. Organizations may choose to employ different mechanisms to achieve confidentiality and integrity protections, as appropriate.\n\nIf the confidentiality and integrity of SQL Server data is not protected, the data will be open to compromise and unauthorized modification.\n\nProtective measures include encryption, physical security of the facility where the storage devices reside, operating system file permissions, and organizational controls.  Each of these should be applied as necessary and appropriate.","descriptions":{"default":"This control is intended to address the confidentiality and integrity of information at rest in non-mobile devices and covers user information and system information.  Information at rest refers to the state of information when it is located on a secondary storage device (e.g., disk drive, tape drive) within an organizational information system. Applications and application users generate information throughout the course of their application use.\n\nUser-generated data, as well as, application-specific configuration data, needs to be protected. Configurations and/or rule sets for firewalls, gateways, intrusion detection/prevention systems, filtering routers, and authenticator content are examples of system information likely requiring protection. Organizations may choose to employ different mechanisms to achieve confidentiality and integrity protections, as appropriate.\n\nIf the confidentiality and integrity of SQL Server data is not protected, the data will be open to compromise and unauthorized modification.\n\nProtective measures include encryption, physical security of the facility where the storage devices reside, operating system file permissions, and organizational controls.  Each of these should be applied as necessary and appropriate.","check":"If the application owner and Authorizing Official have determined that encryption of data at rest is NOT required, this is not a finding.\n\nIf the application owner and Authorizing Official have determined that encryption of data at rest is required, ensure the data on secondary devices is encrypted.\n\nIf full-disk encryption is being used, this is not a finding.\n\nIf DBMS data encryption is required, ensure the data is encrypted before being put on the secondary device by executing:\n\nSELECT\n      d.name AS [Database Name],\n      CASE e.encryption_state\n            WHEN 0 THEN 'No database encryption key present, no encryption'\n            WHEN 1 THEN 'Unencrypted'\n            WHEN 2 THEN 'Encryption in progress'\n            WHEN 3 THEN 'Encrypted'\n            WHEN 4 THEN 'Key change in progress'\n            WHEN 5 THEN 'Decryption in progress'\n            WHEN 6 THEN 'Protection change in progress'\n      END AS [Encryption State]\nFROM sys.dm_database_encryption_keys e\nRIGHT JOIN sys.databases d ON DB_NAME(e.database_id) = d.name\nWHERE d.name NOT IN ('master','model','msdb')\nORDER BY 1\n;\n\nFor each user database where encryption is required, verify that encryption is in effect. If not, this is a finding.\n\nVerify that there are physical security measures, operating system access control lists and organizational controls appropriate to the sensitivity level of the data in the database(s). If not, this is a finding.","fix":"Apply appropriate controls to protect the confidentiality and integrity of data on a secondary device.\n\nWhere encryption is required, this can be done by full-disk encryption or by database encryption. To enable database encryption, create a master key, create a database encryption key, and protect it by using mechanisms tied to the master key, and then set encryption on.\n\nImplement physical security measures, operating system access control lists and organizational controls appropriate to the sensitivity level of the data in the database(s)."},"impact":0.5,"refs":[{"ref":"DPMS Target SQL Server Database 2014"}],"tags":{"check_id":"C-68445r3_chk","severity":"medium","gid":"V-67877","rid":"SV-82367r3_rule","stig_id":"SQL4-00-021300","gtitle":"SRG-APP-000231-DB-000154","fix_id":"F-73993r1_fix","documentable":null,"cci":["CCI-001199"],"nist":["SC-28"]}}],"groups":[{"id":"controls/SV-81847.rb","title":null,"controls":["SV-81847"]},{"id":"controls/SV-81849.rb","title":null,"controls":["SV-81849"]},{"id":"controls/SV-81851.rb","title":null,"controls":["SV-81851"]},{"id":"controls/SV-81855.rb","title":null,"controls":["SV-81855"]},{"id":"controls/SV-81857.rb","title":null,"controls":["SV-81857"]},{"id":"controls/SV-81859.rb","title":null,"controls":["SV-81859"]},{"id":"controls/SV-81861.rb","title":null,"controls":["SV-81861"]},{"id":"controls/SV-81863.rb","title":null,"controls":["SV-81863"]},{"id":"controls/SV-81865.rb","title":null,"controls":["SV-81865"]},{"id":"controls/SV-81867.rb","title":null,"controls":["SV-81867"]},{"id":"controls/SV-81871.rb","title":null,"controls":["SV-81871"]},{"id":"controls/SV-81873.rb","title":null,"controls":["SV-81873"]},{"id":"controls/SV-81875.rb","title":null,"controls":["SV-81875"]},{"id":"controls/SV-81879.rb","title":null,"controls":["SV-81879"]},{"id":"controls/SV-81881.rb","title":null,"controls":["SV-81881"]},{"id":"controls/SV-81883.rb","title":null,"controls":["SV-81883"]},{"id":"controls/SV-81885.rb","title":null,"controls":["SV-81885"]},{"id":"controls/SV-81887.rb","title":null,"controls":["SV-81887"]},{"id":"controls/SV-81889.rb","title":null,"controls":["SV-81889"]},{"id":"controls/SV-81891.rb","title":null,"controls":["SV-81891"]},{"id":"controls/SV-81893.rb","title":null,"controls":["SV-81893"]},{"id":"controls/SV-81895.rb","title":null,"controls":["SV-81895"]},{"id":"controls/SV-81897.rb","title":null,"controls":["SV-81897"]},{"id":"controls/SV-81899.rb","title":null,"controls":["SV-81899"]},{"id":"controls/SV-81901.rb","title":null,"controls":["SV-81901"]},{"id":"controls/SV-81903.rb","title":null,"controls":["SV-81903"]},{"id":"controls/SV-81905.rb","title":null,"controls":["SV-81905"]},{"id":"controls/SV-81907.rb","title":null,"controls":["SV-81907"]},{"id":"controls/SV-81909.rb","title":null,"controls":["SV-81909"]},{"id":"controls/SV-81911.rb","title":null,"controls":["SV-81911"]},{"id":"controls/SV-81913.rb","title":null,"controls":["SV-81913"]},{"id":"controls/SV-81915.rb","title":null,"controls":["SV-81915"]},{"id":"controls/SV-81917.rb","title":null,"controls":["SV-81917"]},{"id":"controls/SV-81919.rb","title":null,"controls":["SV-81919"]},{"id":"controls/SV-81921.rb","title":null,"controls":["SV-81921"]},{"id":"controls/SV-81923.rb","title":null,"controls":["SV-81923"]},{"id":"controls/SV-81925.rb","title":null,"controls":["SV-81925"]},{"id":"controls/SV-81927.rb","title":null,"controls":["SV-81927"]},{"id":"controls/SV-81929.rb","title":null,"controls":["SV-81929"]},{"id":"controls/SV-81931.rb","title":null,"controls":["SV-81931"]},{"id":"controls/SV-81933.rb","title":null,"controls":["SV-81933"]},{"id":"controls/SV-82367.rb","title":null,"controls":["SV-82367"]}],"name":"MS_SQL_Server_2014_Database_STIG","title":null,"maintainer":null,"copyright":null,"copyright_email":null,"license":null,"summary":null,"description":null,"version":"1.0.0","supports":[],"depends":[],"inspec_version":null,"inputs":[],"sha256":"046e0c50f538641461534c1f5367160f25b95ff1cfe35f5515fa4c1566367bac","status_message":"","status":"loaded","generator":{"name":"inspec","version":"6.6.0"}}
